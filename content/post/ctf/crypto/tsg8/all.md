---
title: "TSG lIVE! 8 CTFに参加しました"
date: 2022-05-14T14:49:48+09:00
tags: ["ctf","crypto","writeup","RSA","easy"]
draft: false
---

## はじめに
TSG lIVE! 8 CTFにチーム参加しました．
crypto問を3問中2つ解いたのでwriteupを書きます．

## Forgetful RSA 
`flag`の上位$i$bitを$f_i$と表すことにする．また，$f_i^e \mod n =c_i$とする．
出力された配列`c`を見ると，小さい$i$について$f_i^e<n$であり，$f_i^e = c_i$予想できる．

```none
(f_4)**e = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
(f_3)**e = 43180842775472231269317593140019978555800018221814069251185173508429590158121352898575375173614411328027364697307483179849754947341597334682650188852903738734312355518341064453125
(f_2)**e = 231584178474632390847141970017375815706539969331281128078915168015826259279872
(f_1)**e = 1
```
例えば，次のようにプログラムを掛けば
```python
>>> from gmpy2 import iroot
>>> e = 0x101
>>> c = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
>>> iroot(c,e)
(mpz(10), True)
>>>
```
`flag`の上位4bitが`0b1010`であることがわかる．

次に，最大公約数をうまく使うことで$n$を求める．
$f_5^e n=c_5\mod n$より，$f_5^e - c_5 = 0 \mod n$で，$f_5^e -c_5$は$n$の倍数である．
同様に，$f_6^e - c_6$も$n$の倍数であるから，これらの最大公約数をとることで$n$が得られる．
$f_5$，$f_6$として考えられる値はたかだか$4$通りであるため，全て試せばいい．
```python
from Crypto.Util.number import GCD
c.reverse()
a0 = pow(0b10100,e)
a1 = pow(0b10101,e)
a00 = pow(0b101000,e)
a01 = pow(0b101001,e)
a10 = pow(0b101010,e)
a11 = pow(0b101011,e)
print(GCD(a0-c[5],a00-c[6]))
print(GCD(a0-c[5],a01-c[6]))
print(GCD(a1-c[5],a10-c[6]))
print(GCD(a1-c[5],a11-c[6]))
```
結果は以下の通りである．
```
1
1
142643935303446381001279947550591766064860638332732560752396406069081171879061311344991121502015387733157095870331363131417418514982044480403293728339899298554597845932712399673486772631075556012586672082574811346123474551631303197292734503133958141848155519486123242876455089596670804942778448421334181752913
2
```
これにより，3行目が$n$の値とわかる．

あとは，フラグを1bitずつ伸ばしていって，各$c_i$の値と一致するかを確認していけばよい．
```python
from Crypto.Util.number import long_to_bytes

e = 0x101
n = 142643935303446381001279947550591766064860638332732560752396406069081171879061311344991121502015387733157095870331363131417418514982044480403293728339899298554597845932712399673486772631075556012586672082574811346123474551631303197292734503133958141848155519486123242876455089596670804942778448421334181752913
c.reverse()

m = 0
for i in range(len(c)):
    if i==0:
        continue
    if pow(m*2,e,n)==c[i]:
        m = m*2+0
    if pow(m*2+1,e,n)==c[i]:
        m = m*2+1

print(long_to_bytes(m))
```
```none
b'TSGLIVE{mY_m3MoRy-m4y_Impr0ve_s0me_D4y..._b1t_by_6it!}'
```

## Two Keys
$p$の`nextPrime`を$p+a$，$q$の`nextPrime`を$q+b$とおく．
各$n$を次のように表すことにする．
$$n_1=pq, \quad n_2 =(p+a)(q+b)$$
$n_2$は，$n_1$を使って表すことができる．
$$n_2 = pq + pb + qa + ab = n_1 + pb + qa + ab$$
また，$n_1=pq$より，$q=\frac{n_1}{p}$を代入．
$$n_2 = n_1 + pb + a\frac{n_1}{p}+ab$$
両辺を，$p$倍．
$$pn_2 = pn_1 + p^2 b + an_1+pab$$
整理する．
$$p^2b + p(n_1-n_2+ab) + an_1=0$$
これにより，$p$に関する二次方程式ができる．$a$と$b$は素数間の距離であり，あまり大きくならないと考えられるため，適当な値で探索する．
```python
N1 = 56857358946783738817465975297711204069935415016419932538392922530218921201217352346494361968035470184308357037387164930109496691365401965670237349367799774405061235025947852274083877022468072607753900481316564650009744632767993278947752127202134753913008582254000854930780954253903124752186965795809304941831
N2 = 56857358946783738817465975297711204069935415016419932538392922530218921201217352346494361968035470184308357037387164930109496691365401965670237349367805332556208545324190423359112543995138089627600000504956531406110700016755090783444147649357626603184673602899015609448577621960908326053341685493162553923683

from gmpy2 import iroot
from Crypto.Util.number import *

for a in range(1,1000):
    for b in range(1,1000):
        A = b
        B = N1 - N2 + a*b
        C = a * N1
        D = B*B-4*A*C
        if D<0:
            continue
        D,t=iroot(D,2)
        if t:
            X1 =(-B+D )//(2*A)
            X2 =(-B-D )//(2*A)
        if N1%X1 == 0:
            print(X1)
        if N1%X2 == 0:
            print(X1)
```
これで$p$が得られる．
```
7180400826431487264888758121573735514382183735722336320585544657738663184707542134001295421874439992397088282386645899023064682034148882357611433798725561
```
各パラメータを計算し，フラグが求まる．
```none
TSGLIVE{pr1M3_numb3R5_4R3_pR377y_d3N53_1M0}
```

## 感想
twokeysも解ける問題だったので時間オーバーして悔しかったです．問題がとても面白かったです．


