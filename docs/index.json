[{"content":"これは何 部活動で僕が勝手に新入生向けに開催したJo-ken\u0026rsquo;s beginner Contest 001の解説記事です．\n解説 A - year to seconds 問題概要  1年は何秒か．ただし，1年は365日とする．\n 解説 掛け算の問題です．電卓を叩かなくても，プログラムが計算してくれます．\nPython print(365*24*60*60) C++ #include \u0026lt;iostream\u0026gt; int main(){  cout\u0026lt;\u0026lt;365*60*60\u0026lt;\u0026lt;endl; } B - 単位拾い 問題概要  $P$の値が$60$以上であるか，$60$未満であるかを判定する\n 解答 if文を使います．\nPython pythonを使う場合，インデントに注意しましょう．\np = int(input()) if p \u0026lt; 60:  print(\u0026#34;failed\u0026#34;) else:  print(\u0026#34;passed\u0026#34;) C++ #include \u0026lt;iostream\u0026gt;using namespace std;  int main() {  int p;cin\u0026gt;\u0026gt;p;  if(p\u0026lt;60){  cout\u0026lt;\u0026lt;\u0026#34;failed\u0026#34;\u0026lt;\u0026lt;endl;  }else{  cout\u0026lt;\u0026lt;\u0026#34;passed\u0026#34;\u0026lt;\u0026lt;endl;  } } C - weeks and days 問題概要  今日が$D$日のとき，27日までが何週間何日か．\n 解答 一気に何週間と何日を求めようとするとこんがらかってしまうので，順番に考えていきます．\nSTEP1 誕生日までの日数を求めます．$27-D$日です．\nSTEP2 誕生日までの日数を，何週間何日の表記に変換します．15日が何週間何日であるかを考えとき，$15\\div 7=2\\cdots1$という式は，$15=7\\times2+1$であることを表しています．よって，$A日$は，$A\\div7=a\\cdots b$と計算できるとき，$a$週間$b$日であることがわかります．\nPython d = int(input()) a = 27 - d print(a//7,a%7) C++ #include \u0026lt;iostream\u0026gt;using namespace std;  int main() {  int d;  cin\u0026gt;\u0026gt;d;  int a = 27 - d;  cout\u0026lt;\u0026lt;a/7\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;a%7; } D - 単位数え 解答 $N$個入力があることがわかっているので，$N$を受け取った後に$N$回入力を受け取ります．Pythonを使う場合は，配列に格納しましょう．\nPython n = int(input()) a = 0 # 優 b = 0 # 良 c = 0 # 可 d = 0 # 不可 P = list(map(int, input().split())) for x in P:  if x\u0026gt;=80:  a+=1  elif x\u0026gt;=70:  b+=1  elif x\u0026gt;=60:  c+=1  else:  d+=1  print(a,b,c,d) C++ #include \u0026lt;iostream\u0026gt;using namespace std;  int main() {  int n;cin\u0026gt;\u0026gt;n;  int a=0,b=0,c=0,d=0;  for(int i=0;i\u0026lt;n;i++){  int x;cin\u0026gt;\u0026gt;x;  if(80\u0026lt;=x)a++;  else if(70\u0026lt;=x)b++;  else if(60\u0026lt;=x)c++;  else d++;  }  cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;b\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;c\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;d\u0026lt;\u0026lt;endl; } E - BETAMOto 解答 1文字ずつあるかどうかをチェックしていきます．\nPython S = input() T = \u0026#34;BETAMOto\u0026#34;  for c in T:  find = 0 #みつかったら1にする  for a in S:  if c == a :  find = 1  if find ==0:  print(c) 短く書くと次のようになります．\nS=input() print(\u0026#39; \u0026#39;.join([i for i in\u0026#34;BETAMOto\u0026#34;if i not in S])) C++ # include \u0026lt;iostream\u0026gt; # include \u0026lt;string\u0026gt; using namespace std;  int main(void){  string S;cin\u0026gt;\u0026gt;S;  string T=\u0026#34;BETAMOto\u0026#34;;  for(char\u0026amp;c: T){  bool find = false;  for(char\u0026amp;d: S){  if(c==d)find = true;  }  if(!find)cout\u0026lt;\u0026lt;c\u0026lt;\u0026lt;\u0026#34; \u0026#34;;  } } F - How many? 解答 次の2パターンの並び方が考えられます．\n シバ君の左にケン君がいる($A+B-C-2$人) シバ君の右にケン君がいる($A+B+C$人)  ただし，シバ君の左にケン君がいる並び方は出来ない場合があります． よって，$A,B,C$の値から，シバ君がケン君の左に並ぶことができるかを判定すればよいです．\nケン君が左にいられるかの判定 シバ君が，左から$A$番目にいたとき，シバ君とケン君の間の人数$C$はどこまで大きくできるでしょうか． シバ君の左には，$A-1$人の人がいます．その$A-1$人のうち，シバ君とケン君の間にいるための$C$人とケン君自身($+1$人)， が必要なので，$A-1\\leq C+1$である必要があります．\n同様に，ケン君が右から$B$番目にいたとき，$B-1\\leq C+1$である必要があります．\nよって，$A-1\\leq C+1$かつ$B-1\\leq C+1$のとき$A+B-C-2$，そうでなければ$A+B+C$が答えになります．\nC++ #include \u0026lt;iostream\u0026gt;using namespace std;  int main() {  int A,B,C;cin\u0026gt;\u0026gt;A\u0026gt;\u0026gt;B\u0026gt;\u0026gt;C;  if(C\u0026lt;=min(A-2,B-2)){  cout\u0026lt;\u0026lt;A+B-C-2\u0026lt;\u0026lt;endl;  }else{  cout\u0026lt;\u0026lt;A+B+C\u0026lt;\u0026lt;endl;  } } G - 100億マス計算 TLEについて この問題は，ー見二重のfor文を駆使すれば答えが得られるように感じますが，そのプログラムを提出すると恐らくTLEになります．TLEとはTimeLimitExceed(実行時間制限をオーバーした)のことであり，実行に時間がかかりすぎているということです．この問題の実行時間制限は2秒です．すなわち，より高速に動作するプログラムを作る必要があります．\nこの問題は，$N=10^5$が最大のケースであるため，そのときの二重forの中の処理は$N\\times N=10^{10}$回行われます．いくらコンピュータとはいえ，2秒の間にできる処理は$10^7$回程度です．$10^{10}$回の処理は数秒では終わりません．どうにかして処理の回数を少なくする必要があります．\n解答 $A_1$は，$1$行目に存在する全てのマスの計算で，合計$N$回足し算されています．各$A_i$についてもこれが言えます．同様に，各$B_i$も，$N$回足し算されています． よって，答えは$N(\\sum A_i + \\sum B_i)$となり，$O(N)$で答えを求めることができました．\nこのような，ある数がどの程度答えに影響を与えるかを考えることは競技プログラミングの頻出テクニックです．\nH - Matching 解答 $N$人から$2$人選ぶ全ての組み合わせを計算すると，$N^2=10^{10}$によりTLEします．\n身長が$a,b,c$の3人がいて，$a\u0026lt;b\u0026lt;c$の関係があったとき，$a$と$c$の差が最小になることはありえません．必ず，$a$と$b$の差，$b$と$c$の差よりも$a$と$c$の差の方が大きくなります．\nよって，身長順に並べたとき，隣り合う2人同士の差を全て計算し，その中の最小値を選べばよいです．\nソートについて 配列のソートは関数として用意されていることが多いです．\nC++ #include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std;  int main() {  int N;cin\u0026gt;\u0026gt;N;  vector\u0026lt;int\u0026gt; A(N);  for(int i=0;i\u0026lt;N;i++){  cin\u0026gt;\u0026gt;A[i];  }  sort(A.begin(),A.end());  int m=1000000001;  for(int i=0;i\u0026lt;N-1;i++){  m = min(m,abs(A[i]-A[i+1]));  //cout\u0026lt;\u0026lt;A[i]\u0026lt;\u0026lt;endl;  }  cout\u0026lt;\u0026lt;m\u0026lt;\u0026lt;endl; } Python N = int(input()) l = list(map(int, input().split())) l.sort()  m = abs(l[0]-l[1])  for i in range(N-1):  d = abs(l[i] - l[i+1])  if d \u0026lt; m:  m = d  print(m) I - height order 解答 愚直に実装すると，$O((MN)^2)$かかってしまいます．\n全ての人を，身長と列番号を持たせて配列に入れてからソートすることで，単純に，前から順に見ていき，列に最後に追加した人より身長が高く，列番号が一つ後ろであれば追加する，という方針で解くことができます． Python Pythonでは，「身長」と「どの列にいるか」の2つの情報をタプル型に入れてソートすると簡潔に実装できます．\nサンプル1の例では，\n3 3 4 9 18 5 10 9 13 8 19 という情報を，\n[(4, 0), (9, 0), (18, 0), (5, 1), (10, 1), (9, 1), (13, 2), (8, 2), (19, 2)] というデータに置き換えています．列の番号は$0$から$N-1$であることに注意してください． これをソートすると次のようになります．\n[(4, 0), (5, 1), (8, 2), (9, 0), (9, 1), (10, 1), (13, 2), (18, 0), (19, 2)] タプル型のソートは\n 1番目の値の昇順にソートされる 1番目の値が同じ場合，2番目の値の昇順にソートされる  という規則があるので，問題に合致しています．\n以下実装例です．\nN,M = map(int, input().split()) lst = [] for i in range(N):  l = list(map(int, input().split()))  for j in range(M):  lst.append((l[j],i))  lst.sort()  a = 0 #今何番目の人が欲しいか b = 0 #新しい列の一番うしろの人の身長 cnt = 0 for h,f in lst:  # h:身長,f:何列目の人であるか  if a == f and b\u0026lt;h:  a = (a+1)%N  b = h  cnt += 1  print(cnt) C++ C++では，「身長」と「どの列にいるか」の2つの情報をpair型に入れてソートすると簡潔に実装できます． int main() {  int N,M;cin\u0026gt;\u0026gt;N\u0026gt;\u0026gt;M;  vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; A(0);  rep(i,N)rep(j,M){  int a;cin\u0026gt;\u0026gt;a;  A.push_back({a,i});  }  sort(A.begin(),A.end());  int next=0;  int cnt=0;  int hei=0;  for(auto\u0026amp;s:A){  int h = s.first;  int n = s.second;  if(n==next\u0026amp;\u0026amp;hei\u0026lt;=h){  next=(next+1)%N;  hei = h;  cnt++;  }  }  cout\u0026lt;\u0026lt;cnt\u0026lt;\u0026lt;endl; } J - Score Server 解答 全てのユーザーのスコアを保存しておく配列を作ります．ただし，クエリ通りに配列の中身を変えていると，計算量が$O(QN)$となってしまいTLEします．そこで，最低限必要な要素だけを記録する必要があります．\nまず，最大値を答えるクエリですが，毎回全ての要素を比較する必要はなく，スコアの更新があった要素のみを比較すれば良いです．\nまた，全ユーザーのスコア更新クエリで，$N$全てのスコア変数を変更する必要はなく，「スコアが全員$x$になった」という事実のみを記録しておきます．全ユーザーのスコア更新クエリ後に，その値を変更したかのフラグを保存しておくことで，出力クエリが来たときに，\n 全ユーザースコア更新クエリ後にそのユーザーのスコア更新があったらその値をそのまま出力 そうでなければ最後に行われた全ユーザースコア更新クエリのスコアを出力  すればよいです．\nなお，実際には全ユーザーのスコア更新クエリは複数回来るため，「その値を変更したかのフラグ」の代わりに，何回目の全ユーザー更新クエリ後に変更されたかの情報が必要になります．\nこのような，値が必要になるまで具体的な処理をしない手法を遅延評価と呼びます．\n以上，全てのクエリを$O(1)$で実行できるため，計算量は$O(N+Q)$です．\n#include \u0026lt;iostream\u0026gt; int main() {  int N,Q;cin\u0026gt;\u0026gt;N\u0026gt;\u0026gt;Q;  vector\u0026lt;int\u0026gt; A(N+1,0);  int M = 0;//現在の最大値  int E = 0;//初期化回数  int S = 0;  vector\u0026lt;int\u0026gt; B(N+1,0);//値をi番目の更新後に変更されたらiが入る  vector\u0026lt;int\u0026gt; ans(0);  rep(z,Q){  int t;cin\u0026gt;\u0026gt;t;  if(t==1){  int i;cin\u0026gt;\u0026gt;i;  if(E!=B[i]){  B[i] = E;  A[i] = S;  }  ans.push_back(A[i]);  }else if(t==2){  int i,x;cin\u0026gt;\u0026gt;i\u0026gt;\u0026gt;x;  if(E!=B[i]){  B[i] = E;  A[i] = S;  }  if(A[i]\u0026lt;x)A[i] = x;  if(A[i]\u0026gt;M)M = A[i];  }else if(t==3){  cin\u0026gt;\u0026gt;S;  E++;  M = S;  }else if(t==4){  ans.push_back(M);  }  }  for(int a:ans)cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;endl; } K - height difference 解答 それぞれ$A_{i+1}-A_i=h_i$であるか，$A_i-A_{i+1}=h_i$であるかを$2^{N-1}$全通り探索すればよいです．制約が$N=20$と小さいので$O(2^N)$で間に合います．\n探索方法 $2^{N-1}$通りの探索方法ですが，\n 再帰処理を行う bit全探索を行う  という方法が考えられます． ここでは，bit全探索について説明します．\nやることを整理すると，$*A_1*A_2*A_3*A_4*\\cdots *A_{N-1}$という式で，各$*$に$+$か$-$を入れたし式の値を全て計算し， そのうちの最小値が答えになります．\n例えば，$*A_1*A_2*A_3*A_4$があって，この$4$個の$*$に$+$か$-$を入れる方法を並べると，次のようになります．\n $+,+,+,+$ $+,+,+,-$ $+,+,-,+$ $+,+,-,-$ $+,-,+,+$  $\\vdots$\n $-,-,-,-$  全部で$2^4=16$通りありますが，ここで，$+$と$-$を$0$と$1$に対応させてみましょう．\n $0000$ $0001$ $0010$ $0011$ $0100$  $\\vdots$\n $1111$  どこかで見覚えがありますね．そう，$2$進数です．\nこのように，$N$個の要素を$2$択から選ぶときの$2^N$通りの組み合わせは，$2^N$未満の2進数の各ビットが1であるか，に対応しています．\n以上，実装すると次のようになります．\nC++ #include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt;using namespace std;  int main() {  int N;  vector\u0026lt;long\u0026gt; H(N);  cin\u0026gt;\u0026gt;N;   long sum=0;  for(int i=0;i\u0026lt;N-1;i++){  cin\u0026gt;\u0026gt;H[i];  sum+=H[i];  }  long m=sum;  for(int i=0;i\u0026lt;(1\u0026lt;\u0026lt;N-1);i++){  long sub=0;  for(int k=0;k\u0026lt;N-1;k++){//k番目のビットが立っているか  if(i\u0026amp;(1\u0026lt;\u0026lt;k))sub+=H[k];  }  if(m\u0026gt;abs(sum - 2*sub)){  m = abs(sum - 2*sub);  }  }  cout\u0026lt;\u0026lt;m\u0026lt;\u0026lt;endl;  } Ex - Symmetric Quadratic 学校で習うものの，使い所が謎な行列の活用例，累乗の高速化について面白いなと思っていただけたら幸いです．\nSTEP1: 整数で扱おう まず，整数のままで扱う方法を考えます． 2次方程式の解が$X,Y$の2つであったとき， $(x-X)(x-Y)=x^2-(X+Y)x+XY=0$が成り立ちます．\n$x^2+bx+c=0$と係数を比較すると，$X+Y=-b,XY=c$であることがわかります．\nこれで，$N=1$のときの答え$X+Y$は出ました．\nSTEP2: 対称式であることを利用しよう $X+Y,XY$が基本対称式，求める式も対称式であることに注目します．任意の対称式は，基本対称式で表すことができます．例えば，次のような式が成り立ちます．\n$$X^2+Y^2=(X+Y)^2-2XY$$ $$X^3+Y^3=(X+Y)^3-3XY(X+Y)$$ $$X^4+Y^4=(X+Y)^4-4(X+Y)^2XY+2(XY)^2$$\nSTEP3: 漸化式で表そう 次数が増えるにつれ，基本対称式での表し方は複雑になっていきますが，$X^n+Y^n$を求めるのに$X^{n-1}+Y^{n-1}$と$X^{n-2}+Y^{n-2}$を使用すると簡潔に表すことができます．恒等式であるので，右辺を計算することで証明ができます．\n$$X^{n}+Y^{n}=(X^{n-1}+Y^{n-1})(X+Y)-XY(X^{n-2}+Y^{n-2})$$\nわかりやすくするため，$T_i=x^i+y^i$とおきます．$T_0=X^0+Y^0=2$です．\n$$T_n=T_{n-1}(X+Y)-T_{n-2}XY$$\nこの漸化式により，$T_2,T_3,T_4\u0026hellip;$と順番に求めていくことができるわけですが，$T_{10^{18}}$まで求めるのには時間がかかりすぎてしまします．\nSTEP4: 行列累乗で高速化しよう ここで，線形の漸化式は行列の累乗として表すことができる性質を利用します．\n$$ \\left[ \\begin{matrix} X+Y \u0026amp; -XY \\\\ 1 \u0026amp; 0 \\end{matrix} \\right] \\left[ \\begin{matrix} T_{i-1} \\\\ T_{i-2} \\end{matrix} \\right] = \\left[ \\begin{matrix} T_{i} \\\\ T_{i-1} \\end{matrix} \\right] $$\nよって，次のように書けます．\n$$ \\left[ \\begin{matrix} X+Y \u0026amp; -XY \\\\ 1 \u0026amp; 0 \\end{matrix} \\right] ^{N-1} \\left[ \\begin{matrix} T_0 \\\\ T_1 \\end{matrix} \\right] = \\left[ \\begin{matrix} T_{N} \\\\ T_{N-1} \\end{matrix} \\right] $$\n累乗にするとダブリングという手法で高速に計算することができます． まず，行列ではなく実数で例を示します．$5^{32}$を計算することを考えます． $5^{32}=5\\times 5\\times 5\\times \\cdots \\times 5$ですので，$31$回の掛け算が必要になります． では，次の計算方法はどうでしょうか．\n $5^2 = 5\\times 5$ $5^4 = 5^2\\times 5^2$ $5^8 = 5^4\\times 5^4$ $5^{16} = 5^8\\times 5^8$ $5^{32} = 5^{16}\\times 5^{16}$  なんと，$5$回の掛け算で$5^{32}$を計算することができました．さて，この方法では「$2$の累乗」乗の数しか計算できないと思われるかもしれませんが，実は，任意乗でこの計算方法が使えます． 例えば，$5^{52}$であれば，$5^{32+16+4}$であることを利用して， 先程の計算結果を使って$5^{32}\\times 5^{16} \\times 5^{4}=5^{52}$と加えて2回の掛け算で計算が可能になります．計算量は，指数が$2$の何乗の大きさであるかが関わってくるため$N$乗を計算するとき，$O(\\log N)$です．\nPython Pythonでのコード例を次に示します．\ndef mat_mul(a, b) :  I, J, K = len(a), len(b[0]), len(b)  c = [[0] * J for _ in range(I)]  for i in range(I) :  for j in range(J) :  for k in range(K) :  c[i][j] += a[i][k] * b[k][j]  c[i][j] %= m  return c   def mat_pow(x, n):  y = [[0] * len(x) for _ in range(len(x))]   for i in range(len(x)):  y[i][i] = 1   while n \u0026gt; 0:  if n \u0026amp; 1:  y = mat_mul(x, y)  x = mat_mul(x, x)  n \u0026gt;\u0026gt;= 1   return y   b,c,N = map(int, input().split())  m=1000000007 #10^9+7  A=-b #x+y B=c #x*y  ret=[[A],[2]] mat=[[A,-B],[1,0]] ret=mat_mul(mat_pow(mat,N-1),ret)  print(ret[0][0]) 謝罪 順位表に僕やテスターの方が入って見づらくなってしまい申し訳ございませんでした．\nコンテスト開始してからテスターの方に解いてもらったのでこうなってしまいました． サンプルケースに不備があったり，問題が成り立っていなかったりしたので，準備は念入りにしておくべきです(自戒)．\n蛇足 部活動のみなさん参加してくださり本当にありがとうございます． これだけで競技プログラミングの楽しさを知ってもらう\u0026hellip;というのは難しいかもしれませんが， 少しでも関心を持っていただけたら アルゴ式やAtCoder を覗いてみてください．\n今回は初回ということもあり，プログラミングの文法確認のような問題が多くなってしまいましたが， 次回以降はもうちょっとパズル要素のある面白い問題が作れたらいいと思っています．\n","permalink":"https://shibaken28.github.io/my-blog/post/kyopro/jbc001/","summary":"これは何 部活動で僕が勝手に新入生向けに開催したJo-ken\u0026rsquo;s beginner Contest 001の解説記事です．\n解説 A - year to seconds 問題概要  1年は何秒か．ただし，1年は365日とする．\n 解説 掛け算の問題です．電卓を叩かなくても，プログラムが計算してくれます．\nPython print(365*24*60*60) C++ #include \u0026lt;iostream\u0026gt; int main(){  cout\u0026lt;\u0026lt;365*60*60\u0026lt;\u0026lt;endl; } B - 単位拾い 問題概要  $P$の値が$60$以上であるか，$60$未満であるかを判定する\n 解答 if文を使います．\nPython pythonを使う場合，インデントに注意しましょう．\np = int(input()) if p \u0026lt; 60:  print(\u0026#34;failed\u0026#34;) else:  print(\u0026#34;passed\u0026#34;) C++ #include \u0026lt;iostream\u0026gt;using namespace std;  int main() {  int p;cin\u0026gt;\u0026gt;p;  if(p\u0026lt;60){  cout\u0026lt;\u0026lt;\u0026#34;failed\u0026#34;\u0026lt;\u0026lt;endl;  }else{  cout\u0026lt;\u0026lt;\u0026#34;passed\u0026#34;\u0026lt;\u0026lt;endl;  } } C - weeks and days 問題概要  今日が$D$日のとき，27日までが何週間何日か．","title":"Jo-ken Beginner Contest 001 解説など"},{"content":"競プロメインです．\nC,C++など 前提  コンパイルするファイルが間違っている 実行するファイルが間違っている コンパイルに失敗し，前回コンパイル成功時のファイルを実行している  コンパイルできない  ヘッダがない  人のコードパクってきたときにfuncionalヘッダがなかった   using namespaceがない 変数名とdefineの重複 vector\u0026lt;vector\u0026lt;long\u0026gt;\u0026gt; A(N,vector\u0026lt;int\u0026gt;(0))みたいに型が一致していない \u0026lt;Templete T\u0026gt;の書き忘れ  コーナーケース  N=1,K=0などの極端な値 A=Bのとき 同じクエリが複数回来るかもしれない 自己ループ，同じ辺 0の0乗,0の階乗の定義  実行が終わらない  入力を受け取りすぎている  クエリの数Qと要素数Nが混同してしまう   n重for文でインクリメントする変数を間違える n重for文で変数名が重複 計算量が多い  setに要素を大量に入れている可能性    セグフォ  cinを忘れている 二項係数ライブラリとかの前計算した配列の範囲外参照 文字列の操作中に空文字が登場する 0,1-indexedの混同  その他ハマり modを正しく取れていない  modを取ってない mod(法)の値が間違っている(998244353,1e9+7) modの取り方を間違っている  法が素数でない，逆元が存在しない mod 3とかでの二項係数はルーカスの定理を使う   modを取りながら累積和したときに負の数がでる  (A[r]-A[l-1]+mod)%modみたいな配慮   最後にマイナス1などをしている(0のときに-1が出力されてしまう)  未分類  改行(flush)しないと標準出力にでてこない cin\u0026gt;\u0026gt;a,b;みたいなことをしている  エラーが出ないことがあるのでハマりやすい   switch文でbreak忘れ make cleanを試す 型のパース，intをlongの計算にそのまま突っ込むのは良くない 調和級数の計算量勘違い コンストラクタの名前を間違えている 閉区間，半開区間などの違い  累積和で区間和を出す場合に注意   setやmapでstd::lower_boundなどは使えない  メソッドとして用意されている   01ナップザックで昇順にdpを回してしまった  それは個数制限なし   bool型をint型だと思って  bool値に2以上を入れてもサイレントに1になる   ソート後の配列をソート前の状態として扱ってしまった 格子点とグリッドマス目の関係  角の座標の扱い   不等式における累乗の注意  偶数乗した場合負の数が正になる   ビットシフト演算子の計算順序  四則演算のほうが早い(1\u0026lt;\u0026lt;2+2は1\u0026lt;\u0026lt;4で16になる)   long型リテラルにしわすれてオーバーフロー  1\u0026lt;\u0026lt;40はオーバーフローする．1L\u0026lt;\u0026lt;40が正しい．    (La)TeX  コンパイル時にできるファイルを一旦削除する _などの文字はエスケープしてあげる  関数名，変数名にありがち    ","permalink":"https://shibaken28.github.io/my-blog/post/kyopro/wa/","summary":"競プロメインです．\nC,C++など 前提  コンパイルするファイルが間違っている 実行するファイルが間違っている コンパイルに失敗し，前回コンパイル成功時のファイルを実行している  コンパイルできない  ヘッダがない  人のコードパクってきたときにfuncionalヘッダがなかった   using namespaceがない 変数名とdefineの重複 vector\u0026lt;vector\u0026lt;long\u0026gt;\u0026gt; A(N,vector\u0026lt;int\u0026gt;(0))みたいに型が一致していない \u0026lt;Templete T\u0026gt;の書き忘れ  コーナーケース  N=1,K=0などの極端な値 A=Bのとき 同じクエリが複数回来るかもしれない 自己ループ，同じ辺 0の0乗,0の階乗の定義  実行が終わらない  入力を受け取りすぎている  クエリの数Qと要素数Nが混同してしまう   n重for文でインクリメントする変数を間違える n重for文で変数名が重複 計算量が多い  setに要素を大量に入れている可能性    セグフォ  cinを忘れている 二項係数ライブラリとかの前計算した配列の範囲外参照 文字列の操作中に空文字が登場する 0,1-indexedの混同  その他ハマり modを正しく取れていない  modを取ってない mod(法)の値が間違っている(998244353,1e9+7) modの取り方を間違っている  法が素数でない，逆元が存在しない mod 3とかでの二項係数はルーカスの定理を使う   modを取りながら累積和したときに負の数がでる  (A[r]-A[l-1]+mod)%modみたいな配慮   最後にマイナス1などをしている(0のときに-1が出力されてしまう)  未分類  改行(flush)しないと標準出力にでてこない cin\u0026gt;\u0026gt;a,b;みたいなことをしている  エラーが出ないことがあるのでハマりやすい   switch文でbreak忘れ make cleanを試す 型のパース，intをlongの計算にそのまま突っ込むのは良くない 調和級数の計算量勘違い コンストラクタの名前を間違えている 閉区間，半開区間などの違い  累積和で区間和を出す場合に注意   setやmapでstd::lower_boundなどは使えない  メソッドとして用意されている   01ナップザックで昇順にdpを回してしまった  それは個数制限なし   bool型をint型だと思って  bool値に2以上を入れてもサイレントに1になる   ソート後の配列をソート前の状態として扱ってしまった 格子点とグリッドマス目の関係  角の座標の扱い   不等式における累乗の注意  偶数乗した場合負の数が正になる   ビットシフト演算子の計算順序  四則演算のほうが早い(1\u0026lt;\u0026lt;2+2は1\u0026lt;\u0026lt;4で16になる)   long型リテラルにしわすれてオーバーフロー  1\u0026lt;\u0026lt;40はオーバーフローする．1L\u0026lt;\u0026lt;40が正しい．    (La)TeX  コンパイル時にできるファイルを一旦削除する _などの文字はエスケープしてあげる  関数名，変数名にありがち    ","title":"コーディングでのやらかし"},{"content":"注意  内容の正しさの保証はしません． その場しのぎの，実務で使うとしたらあまりよろしくないテクニックも載せてあります．  実装 define #define all(a) a.begin(),a.end() sort(A.begin(),A.end())やlower_boud(A.begin(),A.end(),x)を， sort(all(A))，lower(all(A),x)のように短縮できる．\nauto 型を推定してくれる．例えば，次のコードで，vectorのXを用意したが，double型に変えたくなったとする．\n vector\u0026lt;int\u0026gt; X(10);  for(int a:X){  cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;endl;  } すると，vectorのintとfor文のintの2つをdoubleに書き換えないといけなくなってしまう．そこで，for文のintをautoにしておくことでvectorの型さえ決めとけば楽になる．\n vector\u0026lt;int\u0026gt; X(10);  for(auto a:X){  cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;endl;  } usingという手もある\n using val = int;  vector\u0026lt;val\u0026gt; X(10);  for(val a:X){  cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;endl;  } その他，型名がよくわかないもの(イテレータ，関数など)に使うと便利である．例えば，次を書くのはしんどいので\n vector\u0026lt;int\u0026gt; X(10);  _Vector_iterator\u0026lt;_Vector_val\u0026lt;_Simple_types\u0026lt;int\u0026gt;\u0026gt;\u0026gt; a = X.begin(); autoを使う．\n vector\u0026lt;int\u0026gt; X(10);  auto a = X.begin(); 関数について 値渡し 引数の中身がコピーされるため，関数内で値をいじっても元の値は変わらない．\nvoid foo(int a){  a = 100; }  int main(void){  int x = 10;  foo(x);  cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;endl; } 参照渡し 直接参照するため，引数をコピーするコストがない． 次の例では配列の引数を戻り値っぽく使っている．\u0026amp;がないと，コピーされたA変更が加わるので，結局main関数の配列Aは空っぽのままになってしまう．\n//約数列挙 void factor(long N,vector\u0026lt;long\u0026gt;\u0026amp;A){  A.clear();  for(long i=1;i\u0026lt;=N;i++){  if(N%i==0){  A.push_back(i);  }  } }  int main(void){  long N=60;  vector\u0026lt;long\u0026gt; A(0);  factor(N,A);  for(auto\u0026amp;f:A)cout\u0026lt;\u0026lt;f\u0026lt;\u0026lt;\u0026#34; \u0026#34;;  //1 2 3 4 5 6 10 12 15 20 30 60 } 参照渡しするけど，中身を書き換えたくないときはconstを付ける．安心．\nvoid foo(const vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp;G){  /* Gを改変しない処理 */ } 参照渡しの引数に変数でないもの(リテラル表記)を突っ込むとエラーが出る．\nvoid swapping(int \u0026amp;a,int \u0026amp;b){  int t=a;  a=b;  b=t; }  int main(void){  int x=5;  //リテラル表記だとエラー  swapping(3,x); } ラムダ式 関数を簡単に表現できる．\n auto func = [](int a,int b,int x){return a*x+b;};  cout\u0026lt;\u0026lt;func(10,5,2)\u0026lt;\u0026lt;endl; 後述する比較関数や，count_ifで重宝する． また，関数を引数や返り値に持つ関数や構造体でも便利(抽象化したセグ木など)．\nコンテナ unique 次のコードで重複を削除する．uniqueは，重複した要素を配列の後ろに追いやるので，その部分をeraseで削除する．sortする必要がある．計算量は$O(要素数)$\nvector\u0026lt;int\u0026gt; A= {3,1,4,1,5}; sort(all(A)); A.erase(unique(all(A)), A.end()); fill 指定した範囲に値を代入してくれる．\nvector\u0026lt;int\u0026gt; A(5); fill(all(A),10); reverse 反転される．\nvector\u0026lt;int\u0026gt; A={1,2,3,4,5}; reverse(all(A)); reverse_copyはコピー先が反転する．\nvector\u0026lt;int\u0026gt; A={1,2,3,4,5}; vector\u0026lt;int\u0026gt; B; reverse_copy(all(A),back_inserter(B)); count_if 条件を満たす要素を数える．\nvector\u0026lt;int\u0026gt; A={1,2,2,3,3,3,4,4,4,4}; cout\u0026lt;\u0026lt;count_if(all(A),[](int \u0026amp;a){return a==3;})\u0026lt;\u0026lt;endl; //3  string S=\u0026#34;coffee\u0026#34;; auto findE = [](char\u0026amp;c){return c==\u0026#39;e\u0026#39;;}; cout\u0026lt;\u0026lt;count_if(all(S),findE)\u0026lt;\u0026lt;endl; //2 比較関数 sort ラムダ式が便利．例はinfo構造体のtimeメンバの昇順で並び替えをしている．\nvector\u0026lt;info\u0026gt; A={{4,1},{3,2},{1,3},{3,4}}; sort(all(A),[](info\u0026amp;l,info\u0026amp;r){return l.time\u0026lt;r.time;}); for(info \u0026amp;a:A){  cout\u0026lt;\u0026lt;a.pos\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;a.time\u0026lt;\u0026lt;endl; } /* 4 1 3 2 1 3 3 4 */ priority_queue ラムダ式を使うのは，functionを経由するらしい． また，priority_queueのtop()メソッドは，比較関数を使って並び替えたときに，一番後ろにくる値が返る．\npriority_queue\u0026lt;info,vector\u0026lt;info\u0026gt;,function\u0026lt;bool(info\u0026amp;,info\u0026amp;)\u0026gt;\u0026gt; qu([](info\u0026amp;l,info\u0026amp;r){return l.time\u0026lt;r.time;}); qu.push(info{4,1}); qu.push(info{3,2}); qu.push(info{1,3}); qu.push(info{3,4}); while(!qu.empty()){  info a = qu.top();qu.pop();  cout\u0026lt;\u0026lt;a.pos\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;a.time\u0026lt;\u0026lt;endl; } /* 3 4 1 3 3 2 4 1 */ 直接ラムダ式を突っ込むのが嫌な場合は，decltypeを使う．\nauto compare = [](info\u0026amp;l,info\u0026amp;r){return l.time\u0026lt;r.time;}; priority_queue\u0026lt;info,vector\u0026lt;info\u0026gt;,decltype(compare)\u0026gt; qu{compare}; 小数関連 表示　 setprecisionや，c言語にもあるprintfが使える．\ndouble r = sqrt(2); printf(\u0026#34;%.10lf\\n\u0026#34;,r); cout\u0026lt;\u0026lt;fixed\u0026lt;\u0026lt;setprecision(10); cout\u0026lt;\u0026lt;r\u0026lt;\u0026lt;endl; //どちらも1.4142135624 切り上げ，切り捨て，四捨五入 cout\u0026lt;\u0026lt;floor(1.5)\u0026lt;\u0026lt;endl;//切り捨て，床関数 1 cout\u0026lt;\u0026lt;ceil(1.5)\u0026lt;\u0026lt;endl;//切り上げ，天井関数 2 cout\u0026lt;\u0026lt;round(1.5)\u0026lt;\u0026lt;endl;//小数点以下を四捨五入 2 cout\u0026lt;\u0026lt;round(1.48)\u0026lt;\u0026lt;endl;//小数点以下を四捨五入 1 範囲for文 vectorやsetなどの要素を列挙する．他の言語のeachfor文にあたる． 汎用性が高い．\nvector vector\u0026lt;int\u0026gt; A={3,1,4,1,5,9,2,6,5,3,5}; for(auto\u0026amp;a:A)cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#34; \u0026#34;; //3 1 4 1 5 9 2 6 5 3 5 set set\u0026lt;int\u0026gt; A={5,1,3,2,4}; for(auto\u0026amp;a:A)cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#34; \u0026#34;; //1 2 3 4 5 map mapはpair型で返る．\nmap\u0026lt;int,int\u0026gt; A={{1,5},{4,5},{2,3},{8,1}}; for(auto\u0026amp;a:A)cout\u0026lt;\u0026lt;\u0026#34;{\u0026#34;\u0026lt;\u0026lt;a.first\u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt;a.second\u0026lt;\u0026lt;\u0026#34;} \u0026#34;; //{1,5} {2,3} {4,5} {8,1} 構造体束縛によって次のようなこともできる．\nmap\u0026lt;int,int\u0026gt; A={{1,5},{4,5},{2,3},{8,1}}; for(auto\u0026amp;[key,value]:A)cout\u0026lt;\u0026lt;\u0026#34;{\u0026#34;\u0026lt;\u0026lt;key\u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt;value\u0026lt;\u0026lt;\u0026#34;} \u0026#34;; //{1,5} {2,3} {4,5} {8,1} 二分探索 範囲が含まれていたり含まれていなかったり，ややこしいのでコピペでできるように整理しておきたい．\nlower_bound 指定した数以上の数うち，最も左にある数のイテレータを返す． 指定した数以上が存在しない場合，.end()のイテレータが返るため，そのまま参照する際には注意．\nvector\u0026lt;int\u0026gt; A={1,1,2,4}; //ソート済みである for(int i=0;i\u0026lt;=5;i++){  auto a = lower_bound(all(A),i);  if(a==A.end()){  cout\u0026lt;\u0026lt;\u0026#34;Aには \u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; 以上の数は含まれません\u0026#34;\u0026lt;\u0026lt;endl;  }else{  cout\u0026lt;\u0026lt;\u0026#34;Aに含まれる \u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; 以上の最小の数 \u0026#34;\u0026lt;\u0026lt;*a\u0026lt;\u0026lt;endl;  cout\u0026lt;\u0026lt;\u0026#34;そのインデックス \u0026#34;\u0026lt;\u0026lt;a-A.begin()\u0026lt;\u0026lt;endl;  }  cout\u0026lt;\u0026lt;\u0026#34;Aに含まれる \u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; 以上の数の個数 \u0026#34;\u0026lt;\u0026lt;A.end()-a\u0026lt;\u0026lt;endl;  cout\u0026lt;\u0026lt;\u0026#34;Aに含まれる \u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; 未満の数の個数 \u0026#34;\u0026lt;\u0026lt;A.size()-(A.end()-a)\u0026lt;\u0026lt;endl;  cout\u0026lt;\u0026lt;endl; } upper_bound 指定した数より大きい数のうち，最も左にある数のイテレータを返す． これまた，存在にない場合の処理に注意．\nvector\u0026lt;int\u0026gt; A={1,1,2,4}; //ソート済みである for(int i=0;i\u0026lt;=5;i++){  auto a = upper_bound(all(A),i);  if(a==A.end()){  cout\u0026lt;\u0026lt;\u0026#34;Aには \u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; より大きい数は含まれません\u0026#34;\u0026lt;\u0026lt;endl;  }else{  cout\u0026lt;\u0026lt;\u0026#34;Aに含まれる \u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; より大きいの最小の数 \u0026#34;\u0026lt;\u0026lt;*a\u0026lt;\u0026lt;endl;  cout\u0026lt;\u0026lt;\u0026#34;そのインデックス \u0026#34;\u0026lt;\u0026lt;a-A.begin()\u0026lt;\u0026lt;endl;  }  cout\u0026lt;\u0026lt;\u0026#34;Aに含まれる \u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; より大きいの数の個数 \u0026#34;\u0026lt;\u0026lt;A.end()-a\u0026lt;\u0026lt;endl;  cout\u0026lt;\u0026lt;\u0026#34;Aに含まれる \u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; 以下の数の個数 \u0026#34;\u0026lt;\u0026lt;A.size()-(A.end()-a)\u0026lt;\u0026lt;endl;  cout\u0026lt;\u0026lt;endl; } xの個数を数える lower_boundとupper_boundを合わせて使うと，ある数の個数が得られる． 具体的には，要素数からx未満の数の個数とxより大きい数の個数を引けば良い．\nvector\u0026lt;int\u0026gt; A={1,1,2,2,2,2,4}; //ソート済みである for(int i=0;i\u0026lt;=5;i++){  auto u = upper_bound(all(A),i);  auto l = lower_bound(all(A),i);  int a = A.end()-u;  int b = A.size()-(A.end()-l);  //cout\u0026lt;\u0026lt;\u0026#34;Aに含まれる \u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; より大きいの数の個数 \u0026#34;\u0026lt;\u0026lt;a\u0026lt;\u0026lt;endl;  //cout\u0026lt;\u0026lt;\u0026#34;Aに含まれる \u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; 未満の数の個数 \u0026#34;\u0026lt;\u0026lt;b\u0026lt;\u0026lt;endl;  cout\u0026lt;\u0026lt;\u0026#34;Aに含まれる \u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; の個数 \u0026#34;\u0026lt;\u0026lt;A.size()-a-b\u0026lt;\u0026lt;endl; } mapやsetに対して mapとsetには，lower_bound,upper_boundメソッドがそれぞれ用意されているので，これを使う(間違えてstd::lower_boundを使うと，正しい値は得られない．なぜなら，beginからendまでのイテレータが連続でないからである．)\n$x$以下の値で大きい方から$k$番目みたいな問題 set,map,multisetでは，イテレータのインクリメント，デクリメントで次に大きい数，小さい数を得られる． イテレータがコンテナの範囲外にあるとセグフォするので注意しなければならない．\n https://atcoder.jp/contests/abc241/tasks/abc241_d  ビット演算 2の冪数 2のn乗が欲しいとき，1\u0026lt;\u0026lt;nで実現できる．オーバーフローに注意．\n cout\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;30)\u0026lt;\u0026lt;endl;  //1073741824,2の30乗 2の冪数判定 次の論理式で2の冪数($2^k,(kは非負整数)$で表すことができる)かを判定できる．\nbool is2exp(long n){  return (n\u0026amp;(n-1))==0; }  int main(void){  //false  cout\u0026lt;\u0026lt;is2exp(10)\u0026lt;\u0026lt;endl;  cout\u0026lt;\u0026lt;is2exp(98)\u0026lt;\u0026lt;endl;  cout\u0026lt;\u0026lt;is2exp(65)\u0026lt;\u0026lt;endl;   //true  cout\u0026lt;\u0026lt;is2exp(32)\u0026lt;\u0026lt;endl;  cout\u0026lt;\u0026lt;is2exp(64)\u0026lt;\u0026lt;endl;  cout\u0026lt;\u0026lt;is2exp(2)\u0026lt;\u0026lt;endl;  cout\u0026lt;\u0026lt;is2exp(1)\u0026lt;\u0026lt;endl;  cout\u0026lt;\u0026lt;is2exp(0)\u0026lt;\u0026lt;endl; } 未分類 Makefile c++17の機能を使いたいので，Makefileでオプションを付けるように指定する．\n#Makefile CC=g++ CFLAGS=-Wall -std=c++17 .SUFFIXES = .cpp objs:=$(wildcard *.cpp) targets:=$(objs:.cpp= ) .PHONY:all all: $(targets) .cpp: $(CC) $(CFLAGS) -o $@ $\u0026lt; 周囲4マスを見る 変化量を配列にする．周囲8マスにも応用できる．\nint x=2,y=2; int dx[4]={1,-1,0,0}; int dy[4]={0,0,1,-1}; for(int i=0;i\u0026lt;4;i++){  cout\u0026lt;\u0026lt;x+dx[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;y+dy[i]\u0026lt;\u0026lt;endl; } swap 型が同じであれば何でもswapしてくれる．$O(1)$．\nvector\u0026lt;int\u0026gt; A(100000,10),B(100000,20); rep(i,1000000)swap(A,B); 順列列挙 vector\u0026lt;int\u0026gt; array(N); for(int i=0;i\u0026lt;N;i++)array[i]=i; do{ \tA.push_back(array); }while(next_permutation(array.begin(),array.end())); clamp 範囲に値を収めてくれる．\ncout\u0026lt;\u0026lt;clamp(-5,0,100)\u0026lt;\u0026lt;endl; //0 cout\u0026lt;\u0026lt;clamp(104,0,100)\u0026lt;\u0026lt;endl;//100 cout\u0026lt;\u0026lt;clamp(4,0,100)\u0026lt;\u0026lt;endl;//4 hypot ベクトルの大きさを求める．2次元と3次元で可能．\ncout\u0026lt;\u0026lt;hypot(1,1)\u0026lt;\u0026lt;endl; //1.41421 cout\u0026lt;\u0026lt;hypot(1,1,1)\u0026lt;\u0026lt;endl; //1.73205 部分集合全列挙 int i=0b10001010; cout\u0026lt;\u0026lt;(static_cast\u0026lt;std::bitset\u0026lt;8\u0026gt;\u0026gt;(i))\u0026lt;\u0026lt;\u0026#34; の部分集合\u0026#34;\u0026lt;\u0026lt;endl; for(int T=i; ; T=(T-1)\u0026amp;i) {  if(T==0)break;  cout\u0026lt;\u0026lt;(static_cast\u0026lt;std::bitset\u0026lt;8\u0026gt;\u0026gt;(T))\u0026lt;\u0026lt;endl; } 基数変換 a進数からb進数に変換する．b\u0026gt;10だと出力が変になる．\nstring atob(string N,long a,long b){  long x=1;  long R=0;//10進数  for(int i=N.size()-1;i\u0026gt;=0;i--){  R+=(N[i]-\u0026#39;0\u0026#39;)*x;  x*=a;  }  string S=\u0026#34;\u0026#34;;  while(R\u0026gt;0){  S.push_back(\u0026#39;0\u0026#39;+R%b);  R/=b;  }  if(S==\u0026#34;\u0026#34;)S=\u0026#34;0\u0026#34;;  reverse(all(S));  return S;  } 考え方 余事象  包除原理  最短経路問題+α 曲がる回数を少なくする，一定回数グラフで頂点間の高速移動ができる，など． 拡張BFS，拡張ダイクストラを考える．\n計算量 ある値が極端に小さい その値を用いて全探索できないか\n$N=10$ $O(N!)$の順列全探索\n$N=20$ $O(2^N)$でビット全探索\n$N=40$ 半分列挙\n$N=100$ $O(N^4),O(N^3\\log X),O(N^3)$，区間dp，行列累乗など\n$N=1000$ $O(N^2\\log X),O(N^2)$，dpなど\n$N=2\\times 10^5$ $O(N),O(N\\log N)$，愚直$O(N^2)$を，アルゴリズムやデータ構造を使って$O(N\\log N)$に改善させる問題が多い．\n$N=10^9,10^{18}$ $O(\\log N),O(1)$ ダブリング，最大公約数，桁dp，二分探索など\n$N=10^{12}$ $O(\\sqrt{N})$，素因数分解，約数列挙\n定数倍高速化  dpで，bool値を取っている場合，long型にして64倍高速化が可能かも 素因数分解をたくさんする場合，先に素数列挙しておく  これは定数倍高速化というのか微妙    円環の構造 数列などの最後と最初を連続しているとみなすときに(人が円の形に並んでいる，などのシュチュエーション)，同じ数列を2つくっつけると楽である．\n期待値，確率  独立に考えられないか  ビット演算  ビットごと独立に考えられる．  XOR  1が奇数個で1，偶数個で0  同じ数が偶数個あれば打ち消す $\\mod 2$の足し算ともいえる   $A\\oplus B = C$のとき，$C\\oplus B =A$ $A\\oplus A = 0$ 可換($A\\oplus B=B\\oplus A$)，結合的  ゲーム  多くの場合，あと1手でゲームが終了する状態から逆算して考える． Grundy数計算 Nim  転倒数  バブルソートの交換回数のこと． BITを使って$O(N\\log N)$  ","permalink":"https://shibaken28.github.io/my-blog/post/kyopro/tec/","summary":"注意  内容の正しさの保証はしません． その場しのぎの，実務で使うとしたらあまりよろしくないテクニックも載せてあります．  実装 define #define all(a) a.begin(),a.end() sort(A.begin(),A.end())やlower_boud(A.begin(),A.end(),x)を， sort(all(A))，lower(all(A),x)のように短縮できる．\nauto 型を推定してくれる．例えば，次のコードで，vectorのXを用意したが，double型に変えたくなったとする．\n vector\u0026lt;int\u0026gt; X(10);  for(int a:X){  cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;endl;  } すると，vectorのintとfor文のintの2つをdoubleに書き換えないといけなくなってしまう．そこで，for文のintをautoにしておくことでvectorの型さえ決めとけば楽になる．\n vector\u0026lt;int\u0026gt; X(10);  for(auto a:X){  cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;endl;  } usingという手もある\n using val = int;  vector\u0026lt;val\u0026gt; X(10);  for(val a:X){  cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;endl;  } その他，型名がよくわかないもの(イテレータ，関数など)に使うと便利である．例えば，次を書くのはしんどいので\n vector\u0026lt;int\u0026gt; X(10);  _Vector_iterator\u0026lt;_Vector_val\u0026lt;_Simple_types\u0026lt;int\u0026gt;\u0026gt;\u0026gt; a = X.begin(); autoを使う．\n vector\u0026lt;int\u0026gt; X(10);  auto a = X.begin(); 関数について 値渡し 引数の中身がコピーされるため，関数内で値をいじっても元の値は変わらない．","title":"競プロで痒いところに手が届くかもしれない情報まとめ"},{"content":"はじめに TSG lIVE! 8 CTFにチーム参加しました． crypto問を3問中2つ解いたのでwriteupを書きます．\nForgetful RSA flagの上位$i$bitを$f_i$と表すことにする．また，$f_i^e \\mod n =c_i$とする． 出力された配列cを見ると，小さい$i$について$f_i^e\u0026lt;n$であり，$f_i^e = c_i$予想できる．\n(f_4)**e = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 (f_3)**e = 43180842775472231269317593140019978555800018221814069251185173508429590158121352898575375173614411328027364697307483179849754947341597334682650188852903738734312355518341064453125 (f_2)**e = 231584178474632390847141970017375815706539969331281128078915168015826259279872 (f_1)**e = 1 例えば，次のようにプログラムを掛けば\n\u0026gt;\u0026gt;\u0026gt; from gmpy2 import iroot \u0026gt;\u0026gt;\u0026gt; e = 0x101 \u0026gt;\u0026gt;\u0026gt; c = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 \u0026gt;\u0026gt;\u0026gt; iroot(c,e) (mpz(10), True) \u0026gt;\u0026gt;\u0026gt; flagの上位4bitが0b1010であることがわかる．\n次に，最大公約数をうまく使うことで$n$を求める． $f_5^e n=c_5\\mod n$より，$f_5^e - c_5 = 0 \\mod n$で，$f_5^e -c_5$は$n$の倍数である． 同様に，$f_6^e - c_6$も$n$の倍数であるから，これらの最大公約数をとることで$n$が得られる． $f_5$，$f_6$として考えられる値はたかだか$4$通りであるため，全て試せばいい．\nfrom Crypto.Util.number import GCD c.reverse() a0 = pow(0b10100,e) a1 = pow(0b10101,e) a00 = pow(0b101000,e) a01 = pow(0b101001,e) a10 = pow(0b101010,e) a11 = pow(0b101011,e) print(GCD(a0-c[5],a00-c[6])) print(GCD(a0-c[5],a01-c[6])) print(GCD(a1-c[5],a10-c[6])) print(GCD(a1-c[5],a11-c[6])) 結果は以下の通りである．\n1 1 142643935303446381001279947550591766064860638332732560752396406069081171879061311344991121502015387733157095870331363131417418514982044480403293728339899298554597845932712399673486772631075556012586672082574811346123474551631303197292734503133958141848155519486123242876455089596670804942778448421334181752913 2 これにより，3行目が$n$の値とわかる．\nあとは，フラグを1bitずつ伸ばしていって，各$c_i$の値と一致するかを確認していけばよい．\nfrom Crypto.Util.number import long_to_bytes  e = 0x101 n = 142643935303446381001279947550591766064860638332732560752396406069081171879061311344991121502015387733157095870331363131417418514982044480403293728339899298554597845932712399673486772631075556012586672082574811346123474551631303197292734503133958141848155519486123242876455089596670804942778448421334181752913 c.reverse()  m = 0 for i in range(len(c)):  if i==0:  continue  if pow(m*2,e,n)==c[i]:  m = m*2+0  if pow(m*2+1,e,n)==c[i]:  m = m*2+1  print(long_to_bytes(m)) b\u0026#39;TSGLIVE{mY_m3MoRy-m4y_Impr0ve_s0me_D4y..._b1t_by_6it!}\u0026#39; Two Keys $p$のnextPrimeを$p+a$，$q$のnextPrimeを$q+b$とおく． 各$n$を次のように表すことにする． $$n_1=pq, \\quad n_2 =(p+a)(q+b)$$ $n_2$は，$n_1$を使って表すことができる． $$n_2 = pq + pb + qa + ab = n_1 + pb + qa + ab$$ また，$n_1=pq$より，$q=\\frac{n_1}{p}$を代入． $$n_2 = n_1 + pb + a\\frac{n_1}{p}+ab$$ 両辺を，$p$倍． $$pn_2 = pn_1 + p^2 b + an_1+pab$$ 整理する． $$p^2b + p(n_1-n_2+ab) + an_1=0$$ これにより，$p$に関する二次方程式ができる．$a$と$b$は素数間の距離であり，あまり大きくならないと考えられるため，適当な値で探索する．\nN1 = 56857358946783738817465975297711204069935415016419932538392922530218921201217352346494361968035470184308357037387164930109496691365401965670237349367799774405061235025947852274083877022468072607753900481316564650009744632767993278947752127202134753913008582254000854930780954253903124752186965795809304941831 N2 = 56857358946783738817465975297711204069935415016419932538392922530218921201217352346494361968035470184308357037387164930109496691365401965670237349367805332556208545324190423359112543995138089627600000504956531406110700016755090783444147649357626603184673602899015609448577621960908326053341685493162553923683  from gmpy2 import iroot from Crypto.Util.number import *  for a in range(1,1000):  for b in range(1,1000):  A = b  B = N1 - N2 + a*b  C = a * N1  D = B*B-4*A*C  if D\u0026lt;0:  continue  D,t=iroot(D,2)  if t:  X1 =(-B+D )//(2*A)  X2 =(-B-D )//(2*A)  if N1%X1 == 0:  print(X1)  if N1%X2 == 0:  print(X1) これで$p$が得られる．\n7180400826431487264888758121573735514382183735722336320585544657738663184707542134001295421874439992397088282386645899023064682034148882357611433798725561 各パラメータを計算し，フラグが求まる．\nTSGLIVE{pr1M3_numb3R5_4R3_pR377y_d3N53_1M0} 感想 twokeysも解ける問題だったので時間オーバーして悔しかったです．問題がとても面白かったです．\n","permalink":"https://shibaken28.github.io/my-blog/post/ctf/crypto/tsg8/all/","summary":"はじめに TSG lIVE! 8 CTFにチーム参加しました． crypto問を3問中2つ解いたのでwriteupを書きます．\nForgetful RSA flagの上位$i$bitを$f_i$と表すことにする．また，$f_i^e \\mod n =c_i$とする． 出力された配列cを見ると，小さい$i$について$f_i^e\u0026lt;n$であり，$f_i^e = c_i$予想できる．\n(f_4)**e = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 (f_3)**e = 43180842775472231269317593140019978555800018221814069251185173508429590158121352898575375173614411328027364697307483179849754947341597334682650188852903738734312355518341064453125 (f_2)**e = 231584178474632390847141970017375815706539969331281128078915168015826259279872 (f_1)**e = 1 例えば，次のようにプログラムを掛けば\n\u0026gt;\u0026gt;\u0026gt; from gmpy2 import iroot \u0026gt;\u0026gt;\u0026gt; e = 0x101 \u0026gt;\u0026gt;\u0026gt; c = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 \u0026gt;\u0026gt;\u0026gt; iroot(c,e) (mpz(10), True) \u0026gt;\u0026gt;\u0026gt; flagの上位4bitが0b1010であることがわかる．\n次に，最大公約数をうまく使うことで$n$を求める． $f_5^e n=c_5\\mod n$より，$f_5^e - c_5 = 0 \\mod n$で，$f_5^e -c_5$は$n$の倍数である． 同様に，$f_6^e - c_6$も$n$の倍数であるから，これらの最大公約数をとることで$n$が得られる． $f_5$，$f_6$として考えられる値はたかだか$4$通りであるため，全て試せばいい．\nfrom Crypto.Util.number import GCD c.reverse() a0 = pow(0b10100,e) a1 = pow(0b10101,e) a00 = pow(0b101000,e) a01 = pow(0b101001,e) a10 = pow(0b101010,e) a11 = pow(0b101011,e) print(GCD(a0-c[5],a00-c[6])) print(GCD(a0-c[5],a01-c[6])) print(GCD(a1-c[5],a10-c[6])) print(GCD(a1-c[5],a11-c[6])) 結果は以下の通りである．","title":"TSG lIVE! 8 CTFに参加しました"},{"content":"LSB Decryption Oracle Attack RSA暗号において，何度も暗号文を復元してくれて，その最も下のビットがわかっている場合，LSB Decryption Oracle Attackが使える． ここでは，入力$x$に対して，$x^d\\mod n$が出力されるものとする． (RSAの各パラメータの説明については省略する．)\n理論 $$(2m)^e = 2^em^e = 2^ec\\mod n$$ が成り立つため，$2^ec\\mod n$を入力として与えると，$(2m)^e\\mod n$を復元することになるため，$2m \\mod n$が返ってくる． この値の偶奇で$m$の範囲がわかる．\n もし，$0\\leq2m\u0026lt;n$の場合，$2m\\mod n$と$2m$は等しいため，$2m \\mod n$は必ず偶数になる． もし，$n\\leq2m\u0026lt;2n$の場合，$2m\\mod n$は$2m-n$と等しいため，$n$が奇数であることから$2m\\mod n$は必ず奇数になる．  $0\u0026lt;m\u0026lt;n$であるから，$2m$がこれ以外の値の範囲をとることはない． これにより，$2m\\mod n$が偶数なら$0\\leq m\u0026lt;\\frac{1}{2}n$，奇数なら$\\frac{1}{2}n\\leq m\u0026lt;n$であることがわかる．\n次に，$4^ec\\mod n$を入力に与えることについて考える．同様に，$4^ec = (4m)^c\\mod n$が成り立つから，$4m\\mod n$の値が返ってくる． 例えば，$2m\\mod n$の出力が偶数で，$0\\leq m\u0026lt;\\frac{1}{2}n$であることが，わかっていたとする．このとき，$4m\\mod n$の偶奇は次のように決まっている．\n $0\\leq4m\u0026lt;n$の場合，$4m\\mod n$は$4m$と等しいため，$4m\\mod n$は必ず偶数になる． $n\\leq4m\u0026lt;2n$の場合，$4m\\mod n$は$4m-n$と等しいため，$4m\\mod n$は必ず奇数になる．  よって，$2m\\mod n$が偶数で， かつ$4m\\mod n$が偶数のときは，$0\\leq m\u0026lt;\\frac{1}{4}n$，奇数のときは$\\frac{1}{4}n\\leq m\u0026lt;\\frac{1}{2}n$であることがわかる．\n同様に，$2m\\mod n$の出力が奇数で，$\\frac{1}{2}n\\leq m\u0026lt;n$であることが，わかっていたとする．このとき，$4m\\mod n$の偶奇は次のように決まっている．\n $2n\\leq4m\u0026lt;3n$の場合，$4m\\mod n$は$4m-2n$と等しいため，$4m\\mod n$は必ず偶数になる． $3n\\leq4m\u0026lt;4n$の場合，$4m\\mod n$は$4m-3n$と等しいため，$4m\\mod n$は必ず奇数になる．  よって，$2m\\mod n$が奇数で， かつ$4m\\mod n$が偶数のときは，$\\frac{1}{2}n\\leq m\u0026lt;\\frac{3}{4}n$，奇数のときは$\\frac{3}{4}n\\leq m\u0026lt;n$であることがわかる．\nこれを繰り返していくと，二分探索の要領でどんどん$m$の取りうる値が半分になっていき，最終的に$m$の値が求まる．\n実装例 整数でl,rを動かすと誤差が出てしまうため，有理数を使っている．\nfrom Crypto.Util.number import * from fractions import Fraction from math import ceil  p = getPrime(256) q = getPrime(256) n = p*q m = bytes_to_long(b\u0026#34;flag{this_is_flag}\u0026#34;) e = 0x10001 c = pow(m,e,n) d = pow(e,-1,(p-1)*(q-1)) assert m\u0026lt;n assert pow(c,d,n)==m  def dec(x):  return pow(x,d,n)  l = 0 r = n a = 1 while abs(r-l)\u0026gt;1:  b=(c*pow(2,a*e,n))%n  de = dec(b)  mid = Fraction(l + r, 2)  if de%2==0:  r = mid  else:  l = mid  a+=1 print(ceil(l)) print(m) 参考サイト  plain RSAに対するLSB decryption oracle attackをやってみる LSB Leak Attackを実装した  を参考にさせて頂きました．\n","permalink":"https://shibaken28.github.io/my-blog/post/ctf/crypto/script/lsb/","summary":"LSB Decryption Oracle Attack RSA暗号において，何度も暗号文を復元してくれて，その最も下のビットがわかっている場合，LSB Decryption Oracle Attackが使える． ここでは，入力$x$に対して，$x^d\\mod n$が出力されるものとする． (RSAの各パラメータの説明については省略する．)\n理論 $$(2m)^e = 2^em^e = 2^ec\\mod n$$ が成り立つため，$2^ec\\mod n$を入力として与えると，$(2m)^e\\mod n$を復元することになるため，$2m \\mod n$が返ってくる． この値の偶奇で$m$の範囲がわかる．\n もし，$0\\leq2m\u0026lt;n$の場合，$2m\\mod n$と$2m$は等しいため，$2m \\mod n$は必ず偶数になる． もし，$n\\leq2m\u0026lt;2n$の場合，$2m\\mod n$は$2m-n$と等しいため，$n$が奇数であることから$2m\\mod n$は必ず奇数になる．  $0\u0026lt;m\u0026lt;n$であるから，$2m$がこれ以外の値の範囲をとることはない． これにより，$2m\\mod n$が偶数なら$0\\leq m\u0026lt;\\frac{1}{2}n$，奇数なら$\\frac{1}{2}n\\leq m\u0026lt;n$であることがわかる．\n次に，$4^ec\\mod n$を入力に与えることについて考える．同様に，$4^ec = (4m)^c\\mod n$が成り立つから，$4m\\mod n$の値が返ってくる． 例えば，$2m\\mod n$の出力が偶数で，$0\\leq m\u0026lt;\\frac{1}{2}n$であることが，わかっていたとする．このとき，$4m\\mod n$の偶奇は次のように決まっている．\n $0\\leq4m\u0026lt;n$の場合，$4m\\mod n$は$4m$と等しいため，$4m\\mod n$は必ず偶数になる． $n\\leq4m\u0026lt;2n$の場合，$4m\\mod n$は$4m-n$と等しいため，$4m\\mod n$は必ず奇数になる．  よって，$2m\\mod n$が偶数で， かつ$4m\\mod n$が偶数のときは，$0\\leq m\u0026lt;\\frac{1}{4}n$，奇数のときは$\\frac{1}{4}n\\leq m\u0026lt;\\frac{1}{2}n$であることがわかる．\n同様に，$2m\\mod n$の出力が奇数で，$\\frac{1}{2}n\\leq m\u0026lt;n$であることが，わかっていたとする．このとき，$4m\\mod n$の偶奇は次のように決まっている．\n $2n\\leq4m\u0026lt;3n$の場合，$4m\\mod n$は$4m-2n$と等しいため，$4m\\mod n$は必ず偶数になる． $3n\\leq4m\u0026lt;4n$の場合，$4m\\mod n$は$4m-3n$と等しいため，$4m\\mod n$は必ず奇数になる．  よって，$2m\\mod n$が奇数で， かつ$4m\\mod n$が偶数のときは，$\\frac{1}{2}n\\leq m\u0026lt;\\frac{3}{4}n$，奇数のときは$\\frac{3}{4}n\\leq m\u0026lt;n$であることがわかる．","title":"LSB Decryption Oracle Attackの実装"},{"content":"概要 What if d is too small? Connect with nc mercury.picoctf.net 36463.\nncの内容\nWelcome to my RSA challenge! e: 103624928593399333320247354911447965825264533650971057319298353304002525474538065318852403512064726461174738193603428106904946146256008284823467554827152762569423678591697957603893052975071382627033744303434383276450203293997261442427812721673950613659922998042873117563940092261133781695925987694748389771773 n: 103910376399608681676353628245393162112102881564697113185356793045870832553995623283598951790023021111968530063336394918465350791877495297372970778126616798657973881785284282419987615918907108230154026098524221387899079560549181123756630931610952760466877749364644405065649111649647375141195338190881890507223 c: 30156643564028622673402640319494318578298751067165305755816959327117523569994850417236902775720256626905433978437761494210359833045159937002407287756120449107903682641130585193469930881110966314401974180644201866961482046321797331181951910878959864017526708803440621343824946268602601257095502437975774863711 解答 eが大きいということは，dが小さくなるので，Wiener\u0026rsquo;s attackが有効． Wiener\u0026rsquo;s attack 短い秘密鍵のRSA暗号への攻撃を参考にさせて頂きました．\nfrom Crypto.Util.number import long_to_bytes  #Welcome to my RSA challenge! e= 103624928593399333320247354911447965825264533650971057319298353304002525474538065318852403512064726461174738193603428106904946146256008284823467554827152762569423678591697957603893052975071382627033744303434383276450203293997261442427812721673950613659922998042873117563940092261133781695925987694748389771773 n= 103910376399608681676353628245393162112102881564697113185356793045870832553995623283598951790023021111968530063336394918465350791877495297372970778126616798657973881785284282419987615918907108230154026098524221387899079560549181123756630931610952760466877749364644405065649111649647375141195338190881890507223 c= 30156643564028622673402640319494318578298751067165305755816959327117523569994850417236902775720256626905433978437761494210359833045159937002407287756120449107903682641130585193469930881110966314401974180644201866961482046321797331181951910878959864017526708803440621343824946268602601257095502437975774863711   def f(a, b):  q, r = a//b, a%b  a0, a1 = 1, q  b0, b1 = 0, 1  while r:  a, b = b, r  q, r = a//b, a%b  a0, a1 = a1, a0 + q*a1  b0, b1 = b1, b0 + q*b1  print(long_to_bytes(pow(c,b1,n)))  f(e,n) このまま実行すると，正しくないdについてもたくさん出力されるので，grep picoなどでフラグを探す．\npython3 solve.py | grep pico b\u0026#39;picoCTF{proving_wiener_2635457}\u0026#39; ","permalink":"https://shibaken28.github.io/my-blog/post/ctf/crypto/pico/dachshund-attacks/","summary":"概要 What if d is too small? Connect with nc mercury.picoctf.net 36463.\nncの内容\nWelcome to my RSA challenge! e: 103624928593399333320247354911447965825264533650971057319298353304002525474538065318852403512064726461174738193603428106904946146256008284823467554827152762569423678591697957603893052975071382627033744303434383276450203293997261442427812721673950613659922998042873117563940092261133781695925987694748389771773 n: 103910376399608681676353628245393162112102881564697113185356793045870832553995623283598951790023021111968530063336394918465350791877495297372970778126616798657973881785284282419987615918907108230154026098524221387899079560549181123756630931610952760466877749364644405065649111649647375141195338190881890507223 c: 30156643564028622673402640319494318578298751067165305755816959327117523569994850417236902775720256626905433978437761494210359833045159937002407287756120449107903682641130585193469930881110966314401974180644201866961482046321797331181951910878959864017526708803440621343824946268602601257095502437975774863711 解答 eが大きいということは，dが小さくなるので，Wiener\u0026rsquo;s attackが有効． Wiener\u0026rsquo;s attack 短い秘密鍵のRSA暗号への攻撃を参考にさせて頂きました．\nfrom Crypto.Util.number import long_to_bytes  #Welcome to my RSA challenge! e= 103624928593399333320247354911447965825264533650971057319298353304002525474538065318852403512064726461174738193603428106904946146256008284823467554827152762569423678591697957603893052975071382627033744303434383276450203293997261442427812721673950613659922998042873117563940092261133781695925987694748389771773 n= 103910376399608681676353628245393162112102881564697113185356793045870832553995623283598951790023021111968530063336394918465350791877495297372970778126616798657973881785284282419987615918907108230154026098524221387899079560549181123756630931610952760466877749364644405065649111649647375141195338190881890507223 c= 30156643564028622673402640319494318578298751067165305755816959327117523569994850417236902775720256626905433978437761494210359833045159937002407287756120449107903682641130585193469930881110966314401974180644201866961482046321797331181951910878959864017526708803440621343824946268602601257095502437975774863711   def f(a, b):  q, r = a//b, a%b  a0, a1 = 1, q  b0, b1 = 0, 1  while r:  a, b = b, r  q, r = a//b, a%b  a0, a1 = a1, a0 + q*a1  b0, b1 = b1, b0 + q*b1  print(long_to_bytes(pow(c,b1,n)))  f(e,n) このまま実行すると，正しくないdについてもたくさん出力されるので，grep picoなどでフラグを探す．","title":"picoGym - Dachshund Attacks"},{"content":"概要 We found a brand new type of encryption, can you break the secret code? (Wrap with picoCTF{})\nmlnklfnknljflfmhjimkmhjhmljhjomhmmjkjpmmjmjkjpjojgjmjpjojojnjojmmkmlmijimhjmmj import string  LOWERCASE_OFFSET = ord(\u0026#34;a\u0026#34;) ALPHABET = string.ascii_lowercase[:16]  def b16_encode(plain): \tenc = \u0026#34;\u0026#34; \tfor c in plain: \tbinary = \u0026#34;{0:08b}\u0026#34;.format(ord(c)) \tenc += ALPHABET[int(binary[:4], 2)] \tenc += ALPHABET[int(binary[4:], 2)] \treturn enc  def shift(c, k): \tt1 = ord(c) - LOWERCASE_OFFSET \tt2 = ord(k) - LOWERCASE_OFFSET \treturn ALPHABET[(t1 + t2) % len(ALPHABET)]  flag = \u0026#34;redacted\u0026#34; key = \u0026#34;redacted\u0026#34; assert all([k in ALPHABET for k in key]) assert len(key) == 1  b16 = b16_encode(flag) enc = \u0026#34;\u0026#34; for i, c in enumerate(b16): \tenc += shift(c, key[i % len(key)]) print(enc) 解答 フラグは，b16_encode，shiftの順に，2段階でエンコードされているので，逆順にデコードしていく． shiftに関しては，assertの条件により，せいぜい16通りである．\nimport string  LOWERCASE_OFFSET = ord(\u0026#34;a\u0026#34;) ALPHABET = string.ascii_lowercase[:16]  def b16_decode(cipher):  plain = \u0026#34;\u0026#34;  i = 0  while i\u0026lt;len(cipher):  plain += chr((ord(cipher[i])-LOWERCASE_OFFSET)\u0026lt;\u0026lt;4)+ord(cipher[i+1])-LOWERCASE_OFFSET)  i+=2  return plain  def shift_rev(c, k): \tt1 = ord(c) - LOWERCASE_OFFSET \tt2 = ord(k) - LOWERCASE_OFFSET \treturn ALPHABET[(t1 - t2 + len(ALPHABET)) % len(ALPHABET)]  enc = \u0026#34;mlnklfnknljflfmhjimkmhjhmljhjomhmmjkjpmmjmjkjpjojgjmjpjojojnjojmmkmlmijimhjmmj\u0026#34;  for k in ALPHABET:  current_enc = \u0026#34;\u0026#34;  for c in enc:  current_enc+=shift_rev(c,k)  print(k,\u0026#34;:\u0026#34;,b16_decode(current_enc)) 結果であるが，フラグっぽい文字列が見つからない．\na : ËÚµÚÛµÇÇËÌÊËÈÉ b : ºÉ¤ÉÊ ¤¶¹¶º¶»» ¹º·¶¸ c : ©¸¸¹s¥v¨¥u©u|¥ªx}ªzx}|tz}||{|z¨©¦v¥z§ d : §¨bedgliglkcilkkjkiei e : qQqTSSZV[XV[ZRX[ZZYZX TX f : v ` @`rCurBvBIrwEJwGEJIAGJIIHIGuvsCrGt g : et_tu?_a2da1e18af49f649806988786deb2a6c h : TcNcd.NP!SP T \u0026#39;PU#(U%#(\u0026#39;/%(\u0026#39;\u0026#39;\u0026amp;\u0026#39;%STQ!P%R i : CR=RS\\x1dO\\x10O\\x1f\\x1fOD\\x12D\\x14\\x17\\x1e\\x17\\x16\\x16BC@\\x10\\x14 \\x03\\x05\\x04\\x032?\\x0f\\x03 k : !0\\x1b01û\\x1b-þ -ý!ýô-\u0026#34;ðõ\u0026#34;òðõôüòõôôóôò !.þ-ò/ l : \\x10 / ê \\x1c\\xad\\x1fì\\x10\\xacã\\x1cïä\\x11\\xa1ïäãëáäããâãá\\x1f\\x1d\\xad\\x1c\\xa1\\x1e \\x0e\\x88èúËýúÊþÊÁúÿÍÂÿÏÍÂÁÉÏÂÁÁÀÁÏýþûËúÏü o : íü×üý·×éºìé¹í¹°éî¼±î¾¼±°¸¾±°°¿°¾ìíêºé¾ë p : ÜëÆëì¦ÆØ©ÛØ¨Ü¨¯ØÝ« Ý­« ¯§­ ¯¯®¯­ÛÜÙ©Ø­Ú 実装を間違えてことを疑うが，検証してみるとそうでもなさそう． 実は，picoCTF{et_tu?_a2da1e18af49f649806988786deb2a6c}がフラグである． 実際に，keyを指定して実行するとmlnklfnknl(以下略)が出力される．\n余談 picoGymにはgoodとbadの評価ができるボタンがありますが，こういうフラグが間違いに見える問題の評価はあまり高くないですね．\n","permalink":"https://shibaken28.github.io/my-blog/post/ctf/crypto/pico/new-ceaser/","summary":"概要 We found a brand new type of encryption, can you break the secret code? (Wrap with picoCTF{})\nmlnklfnknljflfmhjimkmhjhmljhjomhmmjkjpmmjmjkjpjojgjmjpjojojnjojmmkmlmijimhjmmj import string  LOWERCASE_OFFSET = ord(\u0026#34;a\u0026#34;) ALPHABET = string.ascii_lowercase[:16]  def b16_encode(plain): \tenc = \u0026#34;\u0026#34; \tfor c in plain: \tbinary = \u0026#34;{0:08b}\u0026#34;.format(ord(c)) \tenc += ALPHABET[int(binary[:4], 2)] \tenc += ALPHABET[int(binary[4:], 2)] \treturn enc  def shift(c, k): \tt1 = ord(c) - LOWERCASE_OFFSET \tt2 = ord(k) - LOWERCASE_OFFSET \treturn ALPHABET[(t1 + t2) % len(ALPHABET)]  flag = \u0026#34;redacted\u0026#34; key = \u0026#34;redacted\u0026#34; assert all([k in ALPHABET for k in key]) assert len(key) == 1  b16 = b16_encode(flag) enc = \u0026#34;\u0026#34; for i, c in enumerate(b16): \tenc += shift(c, key[i % len(key)]) print(enc) 解答 フラグは，b16_encode，shiftの順に，2段階でエンコードされているので，逆順にデコードしていく． shiftに関しては，assertの条件により，せいぜい16通りである．","title":"picoGym - New Ceaser"},{"content":"概要 A one-time pad is unbreakable, but can you manage to recover the flag? (Wrap with picoCTF{}) nc mercury.picoctf.net 64260 otp.py\n#!/usr/bin/python3 -u import os.path  KEY_FILE = \u0026#34;key\u0026#34; KEY_LEN = 50000 FLAG_FILE = \u0026#34;flag\u0026#34;   def startup(key_location): \tflag = open(FLAG_FILE).read() \tkf = open(KEY_FILE, \u0026#34;rb\u0026#34;).read()  \tstart = key_location \tstop = key_location + len(flag)  \tkey = kf[start:stop] \tkey_location = stop  \tresult = list(map(lambda p, k: \u0026#34;{:02x}\u0026#34;.format(ord(p) ^ k), flag, key)) \tprint(\u0026#34;This is the encrypted flag!\\n{}\\n\u0026#34;.format(\u0026#34;\u0026#34;.join(result)))  \treturn key_location  def encrypt(key_location): \tui = input(\u0026#34;What data would you like to encrypt? \u0026#34;).rstrip() \tif len(ui) == 0 or len(ui) \u0026gt; KEY_LEN: \treturn -1  \tstart = key_location \tstop = key_location + len(ui)  \tkf = open(KEY_FILE, \u0026#34;rb\u0026#34;).read()  \tif stop \u0026gt;= KEY_LEN: \tstop = stop % KEY_LEN \tkey = kf[start:] + kf[:stop] \telse: \tkey = kf[start:stop] \tkey_location = stop  \tresult = list(map(lambda p, k: \u0026#34;{:02x}\u0026#34;.format(ord(p) ^ k), ui, key))  \tprint(\u0026#34;Here ya go!\\n{}\\n\u0026#34;.format(\u0026#34;\u0026#34;.join(result)))  \treturn key_location   print(\u0026#34;******************Welcome to our OTP implementation!******************\u0026#34;) c = startup(0) while c \u0026gt;= 0: \tc = encrypt(c) 解答 裏で何が行われているかを見る． 長さ50000のkeyが用意されていて，key_locationが0にセットされている． 入力があると，keyのkey_location文字目から，その入力の文字数文だけが取り出され，XORされる．そして，key_locationはその文字数分だけ動く．\nxorの性質より，50000文字の入力を与えて，出力を得れば，keyがわかる． 特に，文字コード0\\x00を50000文字連ねれば，そのままkeyが出力される．\n次のスクリプトでは，50000-(フラグ長)の分だけkey_locationを動かして，次の入力でちょうどフラグとxorされた値が出力されるようにしている．\nfrom pwn import *  io = remote(\u0026#34;mercury.picoctf.net\u0026#34;,64260)  S = io.recvuntil(\u0026#34;?\u0026#34;).decode() print(\u0026#34;[+] \u0026#34;,S)  KEY_LEN = 50000 FLAG_LEN = len(\u0026#34;51466d4e5f575538195551416e4f5300413f1b5008684d5504384157046e4959\u0026#34;)//2 out = b\u0026#34;\\x00\u0026#34; * (KEY_LEN-FLAG_LEN) io.sendline(out) io.recvuntil(\u0026#34;?\u0026#34;).decode()  out = b\u0026#34;\\x00\u0026#34; * FLAG_LEN io.sendline(out) S = io.recvuntil(\u0026#34;?\u0026#34;).decode() print(\u0026#34;[+] \u0026#34;,S) [+] Opening connection to mercury.picoctf.net on port 64260: Done solve.py:8: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes S = io.recvuntil(\u0026#34;?\u0026#34;).decode() [+] ******************Welcome to our OTP implementation!****************** This is the encrypted flag! 51466d4e5f575538195551416e4f5300413f1b5008684d5504384157046e4959 What data would you like to encrypt? solve.py:15: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes io.recvuntil(\u0026#34;?\u0026#34;).decode() solve.py:19: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes S = io.recvuntil(\u0026#34;?\u0026#34;).decode() [+] Here ya go! 62275c786663615c783165725c786237225c7863315c7831375c7861305c7838 これにより，次の関係がわかる．\nkey = 62275c786663615c783165725c786237225c7863315c7831375c7861305c7838 flag ^ key = 51466d4e5f575538195551416e4f5300413f1b5008684d5504384157046e4959 \u0026gt;\u0026gt;\u0026gt; a = 0x51466d4e5f575538195551416e4f5300413f1b5008684d5504384157046e4959 ^ 0x62275c786663615c783165725c786237225c7863315c7831375c7861305c7838 \u0026gt;\u0026gt;\u0026gt; from Crypto.Util.number import long_to_bytes \u0026gt;\u0026gt;\u0026gt; long_to_bytes(a) b\u0026#39;3a16944dad432717ccc3945d3d96421a\u0026#39; 数字の羅列が出てきて，失敗したように見えるが，実はこれがそのままpicoCTF{3a16944dad432717ccc3945d3d96421a}とフラグになる．\n感想 間違いだと勘違いするので，フラグの内容は意味のある文字列にしてほしいです！\n","permalink":"https://shibaken28.github.io/my-blog/post/ctf/crypto/pico/easy-peasy/","summary":"概要 A one-time pad is unbreakable, but can you manage to recover the flag? (Wrap with picoCTF{}) nc mercury.picoctf.net 64260 otp.py\n#!/usr/bin/python3 -u import os.path  KEY_FILE = \u0026#34;key\u0026#34; KEY_LEN = 50000 FLAG_FILE = \u0026#34;flag\u0026#34;   def startup(key_location): \tflag = open(FLAG_FILE).read() \tkf = open(KEY_FILE, \u0026#34;rb\u0026#34;).read()  \tstart = key_location \tstop = key_location + len(flag)  \tkey = kf[start:stop] \tkey_location = stop  \tresult = list(map(lambda p, k: \u0026#34;{:02x}\u0026#34;.","title":"picoGym - Easy Peasy"},{"content":"概要 What happens if you have a small exponent? There is a twist though, we padded the plaintext so that (M ** e) is just barely larger than N. Let\u0026rsquo;s decrypt this\nN: 1615765684321463054078226051959887884233678317734892901740763321135213636796075462401950274602405095138589898087428337758445013281488966866073355710771864671726991918706558071231266976427184673800225254531695928541272546385146495736420261815693810544589811104967829354461491178200126099661909654163542661541699404839644035177445092988952614918424317082380174383819025585076206641993479326576180793544321194357018916215113009742654408597083724508169216182008449693917227497813165444372201517541788989925461711067825681947947471001390843774746442699739386923285801022685451221261010798837646928092277556198145662924691803032880040492762442561497760689933601781401617086600593482127465655390841361154025890679757514060456103104199255917164678161972735858939464790960448345988941481499050248673128656508055285037090026439683847266536283160142071643015434813473463469733112182328678706702116054036618277506997666534567846763938692335069955755244438415377933440029498378955355877502743215305768814857864433151287 e: 3 ciphertext (c): 1220012318588871886132524757898884422174534558055593713309088304910273991073554732659977133980685370899257850121970812405700793710546674062154237544840177616746805668666317481140872605653768484867292138139949076102907399831998827567645230986345455915692863094364797526497302082734955903755050638155202890599808146956044568639690002921620304969196755223769438221859424275683828638207433071955615349052424040706261639770492033970498727183446507482899334169592311953247661557664109356372049286283480939368007035616954029177541731719684026988849403756133033533171081378815289443019437298879607294287249591634702823432448559878065453908423094452047188125358790554039587941488937855941604809869090304206028751113018999782990033393577325766685647733181521675994939066814158759362046052998582186178682593597175186539419118605277037256659707217066953121398700583644564201414551200278389319378027058801216150663695102005048597466358061508725332471930736629781191567057009302022382219283560795941554288119544255055962 RSAの問題．$m^e$が$n$よりほんのすこしだけ大きいようである．\n解答 $c = m^e =m^3 \\mod n$は，等式に変形すると，整数$k$を使って次のように表せる． $$m^3 = c + kn$$ $m^e$が$n$よりほんの少しだけ大きいということは，整数$k$は小さいということである． つまり，$k=1,2,3,4,\u0026hellip;$と順に探索していき，$m^3$となる，すなわち3乗根が整数となる値を見つければ良い． 3乗根は，2分探索で求めることができるが，gmpy2のirootを使うと楽である．\nfrom pwn import * from Crypto.Util.number import long_to_bytes from gmpy2 import iroot   n = 1615765684321463054078226051959887884233678317734892901740763321135213636796075462401950274602405095138589898087428337758445013281488966866073355710771864671726991918706558071231266976427184673800225254531695928541272546385146495736420261815693810544589811104967829354461491178200126099661909654163542661541699404839644035177445092988952614918424317082380174383819025585076206641993479326576180793544321194357018916215113009742654408597083724508169216182008449693917227497813165444372201517541788989925461711067825681947947471001390843774746442699739386923285801022685451221261010798837646928092277556198145662924691803032880040492762442561497760689933601781401617086600593482127465655390841361154025890679757514060456103104199255917164678161972735858939464790960448345988941481499050248673128656508055285037090026439683847266536283160142071643015434813473463469733112182328678706702116054036618277506997666534567846763938692335069955755244438415377933440029498378955355877502743215305768814857864433151287 e = 3 c = 1220012318588871886132524757898884422174534558055593713309088304910273991073554732659977133980685370899257850121970812405700793710546674062154237544840177616746805668666317481140872605653768484867292138139949076102907399831998827567645230986345455915692863094364797526497302082734955903755050638155202890599808146956044568639690002921620304969196755223769438221859424275683828638207433071955615349052424040706261639770492033970498727183446507482899334169592311953247661557664109356372049286283480939368007035616954029177541731719684026988849403756133033533171081378815289443019437298879607294287249591634702823432448559878065453908423094452047188125358790554039587941488937855941604809869090304206028751113018999782990033393577325766685647733181521675994939066814158759362046052998582186178682593597175186539419118605277037256659707217066953121398700583644564201414551200278389319378027058801216150663695102005048597466358061508725332471930736629781191567057009302022382219283560795941554288119544255055962  k = 1 while True:  m3 = c + k*n  m , t = iroot(m3,3)  # mに3乗根(整数)，tにm^3==m3のbool値が返る  if t:  print(long_to_bytes(m))  break  k+=1 余分な空白が入っているフラグが出る．\nb\u0026#39; picoCTF{e_sh0u1d_b3_lArg3r_6e2e6bda}\u0026#39; ","permalink":"https://shibaken28.github.io/my-blog/post/ctf/crypto/pico/mini-rsa/","summary":"概要 What happens if you have a small exponent? There is a twist though, we padded the plaintext so that (M ** e) is just barely larger than N. Let\u0026rsquo;s decrypt this\nN: 1615765684321463054078226051959887884233678317734892901740763321135213636796075462401950274602405095138589898087428337758445013281488966866073355710771864671726991918706558071231266976427184673800225254531695928541272546385146495736420261815693810544589811104967829354461491178200126099661909654163542661541699404839644035177445092988952614918424317082380174383819025585076206641993479326576180793544321194357018916215113009742654408597083724508169216182008449693917227497813165444372201517541788989925461711067825681947947471001390843774746442699739386923285801022685451221261010798837646928092277556198145662924691803032880040492762442561497760689933601781401617086600593482127465655390841361154025890679757514060456103104199255917164678161972735858939464790960448345988941481499050248673128656508055285037090026439683847266536283160142071643015434813473463469733112182328678706702116054036618277506997666534567846763938692335069955755244438415377933440029498378955355877502743215305768814857864433151287 e: 3 ciphertext (c): 1220012318588871886132524757898884422174534558055593713309088304910273991073554732659977133980685370899257850121970812405700793710546674062154237544840177616746805668666317481140872605653768484867292138139949076102907399831998827567645230986345455915692863094364797526497302082734955903755050638155202890599808146956044568639690002921620304969196755223769438221859424275683828638207433071955615349052424040706261639770492033970498727183446507482899334169592311953247661557664109356372049286283480939368007035616954029177541731719684026988849403756133033533171081378815289443019437298879607294287249591634702823432448559878065453908423094452047188125358790554039587941488937855941604809869090304206028751113018999782990033393577325766685647733181521675994939066814158759362046052998582186178682593597175186539419118605277037256659707217066953121398700583644564201414551200278389319378027058801216150663695102005048597466358061508725332471930736629781191567057009302022382219283560795941554288119544255055962 RSAの問題．$m^e$が$n$よりほんのすこしだけ大きいようである．\n解答 $c = m^e =m^3 \\mod n$は，等式に変形すると，整数$k$を使って次のように表せる． $$m^3 = c + kn$$ $m^e$が$n$よりほんの少しだけ大きいということは，整数$k$は小さいということである． つまり，$k=1,2,3,4,\u0026hellip;$と順に探索していき，$m^3$となる，すなわち3乗根が整数となる値を見つければ良い． 3乗根は，2分探索で求めることができるが，gmpy2のirootを使うと楽である．\nfrom pwn import * from Crypto.Util.number import long_to_bytes from gmpy2 import iroot   n = 1615765684321463054078226051959887884233678317734892901740763321135213636796075462401950274602405095138589898087428337758445013281488966866073355710771864671726991918706558071231266976427184673800225254531695928541272546385146495736420261815693810544589811104967829354461491178200126099661909654163542661541699404839644035177445092988952614918424317082380174383819025585076206641993479326576180793544321194357018916215113009742654408597083724508169216182008449693917227497813165444372201517541788989925461711067825681947947471001390843774746442699739386923285801022685451221261010798837646928092277556198145662924691803032880040492762442561497760689933601781401617086600593482127465655390841361154025890679757514060456103104199255917164678161972735858939464790960448345988941481499050248673128656508055285037090026439683847266536283160142071643015434813473463469733112182328678706702116054036618277506997666534567846763938692335069955755244438415377933440029498378955355877502743215305768814857864433151287 e = 3 c = 1220012318588871886132524757898884422174534558055593713309088304910273991073554732659977133980685370899257850121970812405700793710546674062154237544840177616746805668666317481140872605653768484867292138139949076102907399831998827567645230986345455915692863094364797526497302082734955903755050638155202890599808146956044568639690002921620304969196755223769438221859424275683828638207433071955615349052424040706261639770492033970498727183446507482899334169592311953247661557664109356372049286283480939368007035616954029177541731719684026988849403756133033533171081378815289443019437298879607294287249591634702823432448559878065453908423094452047188125358790554039587941488937855941604809869090304206028751113018999782990033393577325766685647733181521675994939066814158759362046052998582186178682593597175186539419118605277037256659707217066953121398700583644564201414551200278389319378027058801216150663695102005048597466358061508725332471930736629781191567057009302022382219283560795941554288119544255055962  k = 1 while True:  m3 = c + k*n  m , t = iroot(m3,3)  # mに3乗根(整数)，tにm^3==m3のbool値が返る  if t:  print(long_to_bytes(m))  break  k+=1 余分な空白が入っているフラグが出る．","title":"picoGym - Mini RSA"},{"content":"picoCTFの過去問が，常設ctfとして楽しめるpicoGymの問題です．\n概要 Class, take your seats! It\u0026#39;s PRIME-time for a quiz... nc jupiter.challenges.picoctf.org 18821 ncすると，RSA暗号の基本知識を問われます．\n解答 基本 この問題を解くにあたって，次の各パラメータの関係を知っておく必要があります．\n$p,q$を素数，$n=pq$とする．また，$e$を適当な正の整数とする． 平文(plaintext)を$m$とすると，暗号文(ciphertext)$c$は $$c = m^e \\mod n$$ で計算され，秘密鍵$d$を $$d = e^{-1} \\mod \\phi(n)$$ と計算すると，平文$m$が $$m = c^d \\mod n$$ で求めることができる． なお，この場合，$\\phi(n) = (p-1)(q-1)$である．\npythonでは，$a^b \\mod c$をpow(a,b,c)で計算することができる($b=-1$でも動作する)．\n解法 1問目 ncすると次のメッセージが表示されます．\nGood morning class! It\u0026#39;s me Ms. Adleman-Shamir-Rivest Today we will be taking a pop quiz, so I hope you studied. Cramming just will not do! You will need to tell me if each example is possible, given your extensive crypto knowledge. Inputs and outputs are in decimal. No hex here! #### NEW PROBLEM #### q : 60413 p : 76753 ##### PRODUCE THE FOLLOWING #### n IS THIS POSSIBLE and FEASIBLE? (Y/N): $p,q$の値が与えられ，$n$を求めることは可能ですか？，と聞かれています． $n=pq$の定義より，$n$は計算可能です． このような，単純な計算はpythonのインタラクティブ機能が便利です．\n\u0026gt;\u0026gt;\u0026gt; p = 60413 \u0026gt;\u0026gt;\u0026gt; q = 76753 \u0026gt;\u0026gt;\u0026gt; n = p*q \u0026gt;\u0026gt;\u0026gt; n 4636878989 2問目 #### NEW PROBLEM #### p : 54269 n : 5051846941 ##### PRODUCE THE FOLLOWING #### q IS THIS POSSIBLE and FEASIBLE? (Y/N):y $n,p$の値から$q$を求める問題です．$n=pq$から$p=n/q$で求められそうです． 一応，$n$が$p$で割り切れない場合を考慮しておきます．\n\u0026gt;\u0026gt;\u0026gt; p = 54269 \u0026gt;\u0026gt;\u0026gt; n = 5051846941 \u0026gt;\u0026gt;\u0026gt; q = n//p \u0026gt;\u0026gt;\u0026gt; q 93089 \u0026gt;\u0026gt;\u0026gt; p*q == n True 3問目 #### NEW PROBLEM #### e : 3 n : 12738162802910546503821920886905393316386362759567480839428456525224226445173031635306683726182522494910808518920409019414034814409330094245825749680913204566832337704700165993198897029795786969124232138869784626202501366135975223827287812326250577148625360887698930625504334325804587329905617936581116392784684334664204309771430814449606147221349888320403451637882447709796221706470239625292297988766493746209684880843111138170600039888112404411310974758532603998608057008811836384597579147244737606088756299939654265086899096359070667266167754944587948695842171915048619846282873769413489072243477764350071787327913 ##### PRODUCE THE FOLLOWING #### q p IS THIS POSSIBLE and FEASIBLE? (Y/N):n $pq=n$を満たす$p$と$q$を求める問題です． RSA暗号は，$n$から$p,q$を計算することは困難である(ことを利用して安全性としている)ので，これはできません．実際，頑張れば素因数分解できるかもしれませんが，FEASIBLEという単語が，「単純に可能だ」みたいなニュアンスなので，無理やり素因数分解するのはnot FEASIBLEということなのだと思います．\n4問目 #### NEW PROBLEM #### q : 66347 p : 12611 ##### PRODUCE THE FOLLOWING #### totient(n) IS THIS POSSIBLE and FEASIBLE? (Y/N):y totient(n)とは，$\\phi(n)$のことですので，$p,q$から計算できます．\n\u0026gt;\u0026gt;\u0026gt; q = 66347 \u0026gt;\u0026gt;\u0026gt; P = 12611 \u0026gt;\u0026gt;\u0026gt; (p-1)*(q-1) 836623060 5問目 #### NEW PROBLEM #### plaintext : 6357294171489311547190987615544575133581967886499484091352661406414044440475205342882841236357665973431462491355089413710392273380203038793241564304774271529108729717 e : 3 n : 29129463609326322559521123136222078780585451208149138547799121083622333250646678767769126248182207478527881025116332742616201890576280859777513414460842754045651093593251726785499360828237897586278068419875517543013545369871704159718105354690802726645710699029936754265654381929650494383622583174075805797766685192325859982797796060391271817578087472948205626257717479858369754502615173773514087437504532994142632207906501079835037052797306690891600559321673928943158514646572885986881016569647357891598545880304236145548059520898133142087545369179876065657214225826997676844000054327141666320553082128424707948750331 ##### PRODUCE THE FOLLOWING #### ciphertext IS THIS POSSIBLE and FEASIBLE? (Y/N):y $m,e,n$から$c$を求めます．必要なパラメータは揃っているため，計算可能です．\n\u0026gt;\u0026gt;\u0026gt; m = 6357294171489311547190987615544575133581967886499484091352661406414044440475205342882841236357665973431462491355089413710392273380203038793241564304774271529108729717 \u0026gt;\u0026gt;\u0026gt; e = 3 \u0026gt;\u0026gt;\u0026gt; n = 29129463609326322559521123136222078780585451208149138547799121083622333250646678767769126248182207478527881025116332742616201890576280859777513414460842754045651093593251726785499360828237897586278068419875517543013545369871704159718105354690802726645710699029936754265654381929650494383622583174075805797766685192325859982797796060391271817578087472948205626257717479858369754502615173773514087437504532994142632207906501079835037052797306690891600559321673928943158514646572885986881016569647357891598545880304236145548059520898133142087545369179876065657214225826997676844000054327141666320553082128424707948750331 \u0026gt;\u0026gt;\u0026gt; pow(m,e,n) 256931246631782714357241556582441991993437399854161372646318659020994329843524306570818293602492485385337029697819837182169818816821461486018802894936801257629375428544752970630870631166355711254848465862207765051226282541748174535990314552471546936536330397892907207943448897073772015986097770443616540466471245438117157152783246654401668267323136450122287983612851171545784168132230208726238881861407976917850248110805724300421712827401063963117423718797887144760360749619552577176382615108244813 6問目  #### NEW PROBLEM #### ciphertext : 107524013451079348539944510756143604203925717262185033799328445011792760545528944993719783392542163428637172323512252624567111110666168664743115203791510985709942366609626436995887781674651272233566303814979677507101168587739375699009734588985482369702634499544891509228440194615376339573685285125730286623323 e : 3 n : 27566996291508213932419371385141522859343226560050921196294761870500846140132385080994630946107675330189606021165260590147068785820203600882092467797813519434652632126061353583124063944373336654246386074125394368479677295167494332556053947231141336142392086767742035970752738056297057898704112912616565299451359791548536846025854378347423520104947907334451056339439706623069503088916316369813499705073573777577169392401411708920615574908593784282546154486446779246790294398198854547069593987224578333683144886242572837465834139561122101527973799583927411936200068176539747586449939559180772690007261562703222558103359 ##### PRODUCE THE FOLLOWING #### plaintext IS THIS POSSIBLE and FEASIBLE? (Y/N):n $n,e,c$の値から$m$を見つける問題です． これは，公開鍵のみから平文を解読することになってしまうので，RSA暗号の性質としてはそのようなことはできません． 非常にlow exponent attackができそうな見た目をしていますが，そのまま3乗根をとることはできません．ひっかけ問題．\n7問目 #### NEW PROBLEM #### q : 92092076805892533739724722602668675840671093008520241548191914215399824020372076186460768206814914423802230398410980218741906960527104568970225804374404612617736579286959865287226538692911376507934256844456333236362669879347073756238894784951597211105734179388300051579994253565459304743059533646753003894559 p : 97846775312392801037224396977012615848433199640105786119757047098757998273009741128821931277074555731813289423891389911801250326299324018557072727051765547115514791337578758859803890173153277252326496062476389498019821358465433398338364421624871010292162533041884897182597065662521825095949253625730631876637 e : 65537 ##### PRODUCE THE FOLLOWING #### d IS THIS POSSIBLE and FEASIBLE? (Y/N):y $p,q$から$\\phi(n)$が計算できます．\n\u0026gt;\u0026gt;\u0026gt; p = 92092076805892533739724722602668675840671093008520241548191914215399824020372076186460768206814914423802230398410980218741906960527104568970225804374404612617736579286959865287226538692911376507934256844456333236362669879347073756238894784951597211105734179388300051579994253565459304743059533646753003894559 \u0026gt;\u0026gt;\u0026gt; q = 97846775312392801037224396977012615848433199640105786119757047098757998273009741128821931277074555731813289423891389911801250326299324018557072727051765547115514791337578758859803890173153277252326496062476389498019821358465433398338364421624871010292162533041884897182597065662521825095949253625730631876637 \u0026gt;\u0026gt;\u0026gt; phi = (p-1)*(q-1) \u0026gt;\u0026gt;\u0026gt; e = 65537 \u0026gt;\u0026gt;\u0026gt; pow(e,-1,phi) 1405046269503207469140791548403639533127416416214210694972085079171787580463776820425965898174272870486015739516125786182821637006600742140682552321645503743280670839819078749092730110549881891271317396450158021688253989767145578723458252769465545504142139663476747479225923933192421405464414574786272963741656223941750084051228611576708609346787101088759062724389874160693008783334605903142528824559223515203978707969795087506678894006628296743079886244349469131831225757926844843554897638786146036869572653204735650843186722732736888918789379054050122205253165705085538743651258400390580971043144644984654914856729 8問目 #### NEW PROBLEM #### p : 153143042272527868798412612417204434156935146874282990942386694020462861918068684561281763577034706600608387699148071015194725533394126069826857182428660427818277378724977554365910231524827258160904493774748749088477328204812171935987088715261127321911849092207070653272176072509933245978935455542420691737433 ciphertext : 13433290949680532374013867441263154634705815037382789341947905025573905974395028146503162155477260989520870175638250366834087929309236841056522311567941474209163559687755762232926539910909326834168973560610986090744435081572047926364479629414399701920441091626046861493465214197526650146669009590360242375313096062285541413327190041808752295242278877995930751460977420696964385608409717277431821765402461515639686537904799084682553530460611519251872463837425068958992042166507373556839377045616866221238932332390930404993242351071392965945718308504231468783743378794612151028803489143522912976113314577732444166162766 e : 65537 n : 23952937352643527451379227516428377705004894508566304313177880191662177061878993798938496818120987817049538365206671401938265663712351239785237507341311858383628932183083145614696585411921662992078376103990806989257289472590902167457302888198293135333083734504191910953238278860923153746261500759411620299864395158783509535039259714359526738924736952759753503357614939203434092075676169179112452620687731670534906069845965633455748606649062394293289967059348143206600765820021392608270528856238306849191113241355842396325210132358046616312901337987464473799040762271876389031455051640937681745409057246190498795697239 ##### PRODUCE THE FOLLOWING #### plaintext IS THIS POSSIBLE and FEASIBLE? (Y/N):y 方針としては，\n まず，$n,p$から$q$を計算 $p,q$から$\\phi(n)$を計算 $e,phi(n)$から$e$を計算 $c,e,n$から$m$を計算  をすることで平文$m$が求まります．\n\u0026gt;\u0026gt;\u0026gt; p = 153143042272527868798412612417204434156935146874282990942386694020462861918068684561281763577034706600608387699148071015194725533394126069826857182428660427818277378724977554365910231524827258160904493774748749088477328204812171935987088715261127321911849092207070653272176072509933245978935455542420691737433 \u0026gt;\u0026gt;\u0026gt; n = 23952937352643527451379227516428377705004894508566304313177880191662177061878993798938496818120987817049538365206671401938265663712351239785237507341311858383628932183083145614696585411921662992078376103990806989257289472590902167457302888198293135333083734504191910953238278860923153746261500759411620299864395158783509535039259714359526738924736952759753503357614939203434092075676169179112452620687731670534906069845965633455748606649062394293289967059348143206600765820021392608270528856238306849191113241355842396325210132358046616312901337987464473799040762271876389031455051640937681745409057246190498795697239 \u0026gt;\u0026gt;\u0026gt; e = 65537 \u0026gt;\u0026gt;\u0026gt; c = 13433290949680532374013867441263154634705815037382789341947905025573905974395028146503162155477260989520870175638250366834087929309236841056522311567941474209163559687755762232926539910909326834168973560610986090744435081572047926364479629414399701920441091626046861493465214197526650146669009590360242375313096062285541413327190041808752295242278877995930751460977420696964385608409717277431821765402461515639686537904799084682553530460611519251872463837425068958992042166507373556839377045616866221238932332390930404993242351071392965945718308504231468783743378794612151028803489143522912976113314577732444166162766 \u0026gt;\u0026gt;\u0026gt; q = n//p \u0026gt;\u0026gt;\u0026gt; q 156408916769576372285319235535320446340733908943564048157238512311891352879208957302116527435165097143521156600690562005797819820759620198602417583539668686152735534648541252847927334505648478214810780526425005943955838623325525300844493280040860604499838598837599791480284496210333200247148213274376422459183 \u0026gt;\u0026gt;\u0026gt; p*q == n True \u0026gt;\u0026gt;\u0026gt; phi = (p-1)*(q-1) \u0026gt;\u0026gt;\u0026gt; pow(e,-1,phi) 22034129334251191532436631052427142022088744911087428294376533303549714947731798818325604737385904031714383011477708757017443918217594934051491731465975983129741023155187658874730504062262863677059204116473042418196655483682312571059072267891580301964167098006533984400230039789561227549336513668349914598133972091774519248676772440875769025772999278219313806132022105603602125065517276257780089695487263525233311631530270816107086663522684249560931634897706468898520986823978521565593553989544219514141658868117625286137870896148765109851519254459305427251830096270116145359667655034114642356864731801259263519426097 \u0026gt;\u0026gt;\u0026gt; d = pow(e,-1,phi) \u0026gt;\u0026gt;\u0026gt; pow(c,d,n) 14311663942709674867122208214901970650496788151239520971623411712977120527163003942343369341 If you convert the last plaintext to a hex number, then ascii, you\u0026#39;ll find what you need! ;) この答えがそのままflagになっているので，デコードします．\n\u0026gt;\u0026gt;\u0026gt; from Crypto.Util.number import long_to_bytes \u0026gt;\u0026gt;\u0026gt; long_to_bytes(14311663942709674867122208214901970650496788151239520971623411712977120527163003942343369341) b\u0026#39;picoCTF{wA8_th4t$_ill3aGal..oa2d2239b}\u0026#39; 余談 Noと答える問題は混乱するので，ない方が良かったと思います\u0026hellip;\u0026hellip; あと，ncを繋いだまま計算することになるので，地味にタイムアウトが厳しいです． 何回か周回することになりました．\n","permalink":"https://shibaken28.github.io/my-blog/post/ctf/crypto/pico/rsa-pop-quiz/","summary":"picoCTFの過去問が，常設ctfとして楽しめるpicoGymの問題です．\n概要 Class, take your seats! It\u0026#39;s PRIME-time for a quiz... nc jupiter.challenges.picoctf.org 18821 ncすると，RSA暗号の基本知識を問われます．\n解答 基本 この問題を解くにあたって，次の各パラメータの関係を知っておく必要があります．\n$p,q$を素数，$n=pq$とする．また，$e$を適当な正の整数とする． 平文(plaintext)を$m$とすると，暗号文(ciphertext)$c$は $$c = m^e \\mod n$$ で計算され，秘密鍵$d$を $$d = e^{-1} \\mod \\phi(n)$$ と計算すると，平文$m$が $$m = c^d \\mod n$$ で求めることができる． なお，この場合，$\\phi(n) = (p-1)(q-1)$である．\npythonでは，$a^b \\mod c$をpow(a,b,c)で計算することができる($b=-1$でも動作する)．\n解法 1問目 ncすると次のメッセージが表示されます．\nGood morning class! It\u0026#39;s me Ms. Adleman-Shamir-Rivest Today we will be taking a pop quiz, so I hope you studied. Cramming just will not do!","title":"picoGym - rsa-pop-quiz"},{"content":"問題 ctfTimeの問題ページ out.txtは次のようになっています．\np = 127557933868274766492781168166651795645253551106939814103375361345423596703884421796150924794852741931334746816404778765897684777811408386179315837751682393250322682273488477810275794941270780027115435485813413822503016999058941190903932883823 e1 = 219560036291700924162367491740680392841 e2 = 325829142086458078752836113369745585569 e3 = 237262361171684477270779152881433264701 c = 962976093858853504877937799237367527464560456536071770645193845048591657714868645727169308285896910567283470660044952959089092802768837038911347652160892917850466319249036343642773207046774240176141525105555149800395040339351956120433647613 平文を$m$，ある素数を$p$とすると，$m^e \\bmod p = c$として暗号文$c$を求めています．ただし，$e = {e_1}^{{e_2}^{e_3}}$です． $e_1,e_2,e_3$が与えられているので，$e$を求めれば $d = e^{-1} \\pmod{\\phi(p)} $として$c^d \\pmod p$で平文が求まります．\nしかし，$e$を実際に計算しようとすると無限時間かかります． どう計算するかが問題です．\n解答 $e$の値は$\\bmod {\\phi(p)}$の世界で考えても問題ありません． ${e_1}^{{e_2}^{e_3}} \\pmod{\\phi(p)}$の値を求めていきます． オイラーの定理より，次が成り立ちます． $${e_1}^{\\phi(\\phi(p))} = 1 \\pmod{\\phi(p)} $$ $p$は素数であるので，$\\phi(p)=p-1$です(フェルマーの小定理)．よって，次のように書き換えられます． $${e_1}^{\\phi(p-1)} = 1 \\pmod{p-1}$$\n整数$k$と$l$を使って，${e_2}^{e_3} = \\phi(p-1)k+l$と表されたとします．これは，${e_2}^{e_3}$を$\\phi(p-1)$で割ったときに商が$k$，余りが$l$になったことを表しています． すると， $${e_1}^{{e_2}^{e_3}} = {e_1}^{ \\phi(p-1)k+l} = ({e_1}^{\\phi(p-1)})^k\\cdot {e_1}^l = 1^k \\cdot {e_1}^l = {e_1}^l \\pmod{p-1}$$\nと計算できます．つまり，$l={e_2}^{e_3} \\pmod{\\phi(p-1)}$として，${e_1}^l \\pmod{p-1}$を計算すれば$e$が求まります．\n$\\phi(p-1)$を計算するには，$p-1$を素因数分解しなければなりませんが，$p-1$は小さい素因数で構成(smooth呼ばれる性質です)されているため，愚直なプログラムで素因数が求まります．1\n以下，pythonでのプログラムを示します． なお，sagemathにはeuler_phi関数が用意されています．\nfrom Crypto.Util.number import long_to_bytes  def euler_phi(N):  factor = []  i = 2  # 素因数分解  while True:  if i*i\u0026gt;N:  factor.append(N)  break  if N%i==0:  factor.append(i)  N = N // i  else:  i+=1   # 素因数-1を掛け算していく  phi = 1  for p in factor:  phi *= p-1   return phi  p = 127557933868274766492781168166651795645253551106939814103375361345423596703884421796150924794852741931334746816404778765897684777811408386179315837751682393250322682273488477810275794941270780027115435485813413822503016999058941190903932883823 e1 = 219560036291700924162367491740680392841 e2 = 325829142086458078752836113369745585569 e3 = 237262361171684477270779152881433264701 c = 962976093858853504877937799237367527464560456536071770645193845048591657714868645727169308285896910567283470660044952959089092802768837038911347652160892917850466319249036343642773207046774240176141525105555149800395040339351956120433647613  phi_p = p - 1 phi_phi_p = euler_phi(phi_p)  e = pow(e1,pow(e2,e3,phi_phi_p), phi_p) d = pow(e,-1,phi_p) m = pow(c,d,p)  print(\u0026#34;phi(p) : \u0026#34;,phi_p) print(\u0026#34;phi(phi(p)): \u0026#34;,phi_phi_p) print(long_to_bytes(m)) 結果\nphi(p) : 127557933868274766492781168166651795645253551106939814103375361345423596703884421796150924794852741931334746816404778765897684777811408386179315837751682393250322682273488477810275794941270780027115435485813413822503016999058941190903932883822 phi(phi(p)): 63775594668498404422995279661693309334486076035802944116275814269950078792958445557761589097717204934857369990271713664698474867142217580223510594284968730411939236198524531363514002763605853593498040656788050786948899096447734618521600000000 b\u0026#39;crew{7hi5_1s_4_5ma11er_numb3r_7han_7h3_Gr4ham_numb3r}\u0026#39;   追記(2022/5/9)：ここに示したphiを計算するプログラムは不十分でした．低確率ながら，同じ素数が2つ以上含まれる可能性があるからです．その場合は$p^e$とすると$p^e-p^{e-1}$の掛け算が必要になります\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://shibaken28.github.io/my-blog/post/ctf/crypto/crew/thehugee/","summary":"問題 ctfTimeの問題ページ out.txtは次のようになっています．\np = 127557933868274766492781168166651795645253551106939814103375361345423596703884421796150924794852741931334746816404778765897684777811408386179315837751682393250322682273488477810275794941270780027115435485813413822503016999058941190903932883823 e1 = 219560036291700924162367491740680392841 e2 = 325829142086458078752836113369745585569 e3 = 237262361171684477270779152881433264701 c = 962976093858853504877937799237367527464560456536071770645193845048591657714868645727169308285896910567283470660044952959089092802768837038911347652160892917850466319249036343642773207046774240176141525105555149800395040339351956120433647613 平文を$m$，ある素数を$p$とすると，$m^e \\bmod p = c$として暗号文$c$を求めています．ただし，$e = {e_1}^{{e_2}^{e_3}}$です． $e_1,e_2,e_3$が与えられているので，$e$を求めれば $d = e^{-1} \\pmod{\\phi(p)} $として$c^d \\pmod p$で平文が求まります．\nしかし，$e$を実際に計算しようとすると無限時間かかります． どう計算するかが問題です．\n解答 $e$の値は$\\bmod {\\phi(p)}$の世界で考えても問題ありません． ${e_1}^{{e_2}^{e_3}} \\pmod{\\phi(p)}$の値を求めていきます． オイラーの定理より，次が成り立ちます． $${e_1}^{\\phi(\\phi(p))} = 1 \\pmod{\\phi(p)} $$ $p$は素数であるので，$\\phi(p)=p-1$です(フェルマーの小定理)．よって，次のように書き換えられます． $${e_1}^{\\phi(p-1)} = 1 \\pmod{p-1}$$\n整数$k$と$l$を使って，${e_2}^{e_3} = \\phi(p-1)k+l$と表されたとします．これは，${e_2}^{e_3}$を$\\phi(p-1)$で割ったときに商が$k$，余りが$l$になったことを表しています． すると， $${e_1}^{{e_2}^{e_3}} = {e_1}^{ \\phi(p-1)k+l} = ({e_1}^{\\phi(p-1)})^k\\cdot {e_1}^l = 1^k \\cdot {e_1}^l = {e_1}^l \\pmod{p-1}$$\nと計算できます．つまり，$l={e_2}^{e_3} \\pmod{\\phi(p-1)}$として，${e_1}^l \\pmod{p-1}$を計算すれば$e$が求まります．","title":"CrewCTF 2022 - The Huge E"},{"content":"目的 しょっちゅう忘れてはググってるのでまとめます．\nPython標準機能 文字コード変換 基数変換 Crypto.Util.number long_to_bytes,bytes_to_long bytes型とlong型を変換する．\n\u0026gt;\u0026gt;\u0026gt; bytes_to_long(b\u0026#39;hello\u0026#39;) 448378203247 \u0026gt;\u0026gt;\u0026gt; long_to_bytes(0x68656c6c6f) b\u0026#39;hello\u0026#39; inverse inverse(a,b)でaをmodbでの逆元を得られる．\n\u0026gt;\u0026gt;\u0026gt; inverse(3,7) 5 \u0026gt;\u0026gt;\u0026gt; 3*inverse(3,7)%7 1 なお，デフォルトで使えるpow関数で代用可能．\n\u0026gt;\u0026gt;\u0026gt; pow(3,-1,7) 5 getPrime getPrime(a)でaビットの素数が生成される\n\u0026gt;\u0026gt;\u0026gt; getPrime(10) 911 \u0026gt;\u0026gt;\u0026gt; bin(911) \u0026#39;0b1110001111\u0026#39; \u0026gt;\u0026gt;\u0026gt; Crypto.PublicKey pemファイルを開くことができる． openssl rsa -text -in idk.key\n使用例\nfrom Crypto.PublicKey import RSA f=open(\u0026#39;key.pem\u0026#39;,\u0026#39;rb\u0026#39;) pubkey = RSA.importKey(f.read()) print(pubkey) print(\u0026#34;n:\u0026#34;,pubkey.n) print(\u0026#34;e:\u0026#34;,pubkey.e) gmpy2 iroot iroot(a,b)でaのb乗根が得られる．タプル型で返る．\nsagemath  ","permalink":"https://shibaken28.github.io/my-blog/post/ctf/crypto/general/","summary":"目的 しょっちゅう忘れてはググってるのでまとめます．\nPython標準機能 文字コード変換 基数変換 Crypto.Util.number long_to_bytes,bytes_to_long bytes型とlong型を変換する．\n\u0026gt;\u0026gt;\u0026gt; bytes_to_long(b\u0026#39;hello\u0026#39;) 448378203247 \u0026gt;\u0026gt;\u0026gt; long_to_bytes(0x68656c6c6f) b\u0026#39;hello\u0026#39; inverse inverse(a,b)でaをmodbでの逆元を得られる．\n\u0026gt;\u0026gt;\u0026gt; inverse(3,7) 5 \u0026gt;\u0026gt;\u0026gt; 3*inverse(3,7)%7 1 なお，デフォルトで使えるpow関数で代用可能．\n\u0026gt;\u0026gt;\u0026gt; pow(3,-1,7) 5 getPrime getPrime(a)でaビットの素数が生成される\n\u0026gt;\u0026gt;\u0026gt; getPrime(10) 911 \u0026gt;\u0026gt;\u0026gt; bin(911) \u0026#39;0b1110001111\u0026#39; \u0026gt;\u0026gt;\u0026gt; Crypto.PublicKey pemファイルを開くことができる． openssl rsa -text -in idk.key\n使用例\nfrom Crypto.PublicKey import RSA f=open(\u0026#39;key.pem\u0026#39;,\u0026#39;rb\u0026#39;) pubkey = RSA.importKey(f.read()) print(pubkey) print(\u0026#34;n:\u0026#34;,pubkey.n) print(\u0026#34;e:\u0026#34;,pubkey.e) gmpy2 iroot iroot(a,b)でaのb乗根が得られる．タプル型で返る．\nsagemath  ","title":"crypto問でよく使うライブラリ，関数など"}]