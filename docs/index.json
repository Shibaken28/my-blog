[{"content":"前提  コンパイルするファイルが間違っている 実行するファイルが間違っている コンパイルに失敗し，前回コンパイル成功時のファイルを実行している  コンパイルできない  ヘッダがない  人のコードパクってきたときにfuncional.hがなかった   using namespaceがない 変数名とdefineの重複 vector\u0026lt;vector\u0026lt;long\u0026gt;\u0026gt; A(N,vector\u0026lt;int\u0026gt;(0))みたいに型が一致していない \u0026lt;Templete T\u0026gt;の書き忘れ  コーナーケース  N=1,K=0などの極端な値 A=Bのとき 同じクエリが複数回来るかもしれない 自己ループ，同じ辺 0の0乗  実行が終わらない  入力を受け取りすぎている  クエリの数Qと要素数Nが混同してしまう   n重for文でインクリメントする変数を間違える n重for文で変数名が重複 計算量が多い  setに要素を大量に入れている可能性    セグフォ  cinを忘れている 二項係数ライブラリとかの前計算した配列の範囲外参照 文字列の操作中に空文字が登場する 0,1-indexedの混同  その他ハマり modを正しく取れていない  modを取ってない mod(法)の値が間違っている(998244353,1e9+7) modの取り方を間違っている  法が素数でない，逆元が存在しない mod 3とかでの二項係数はルーカスの定理を使う   modを取りながら累積和したときに負の数がでる  (A[r]-A[l-1]+mod)%mod みたいな配慮   最後にマイナス1などをしている(0のときに-1が出力されてしまう)  未分類  改行(flush)しないと標準出力にでてこない cin\u0026raquo;a,b;みたいなことをしている  エラーが出ないことがあるのでハマりやすい   switch文でbreak忘れ make clean 型のパース，intをlongの計算にそのまま突っ込むのは良くない コンストラクタの名前を間違えている 閉区間，半開区間などの違い setやmapでstd::lower_boundなどは使えない  メソッドとして用意されている   01ナップザックで昇順にdpを回してしまった  それは個数制限なし   bool型をint型だと思って  bool値に2以上を入れてもサイレントに1になる   ソート後の配列をソート前の状態として扱ってしまった 格子点とグリッドマス目の関係  角の座標の扱い   不等式における累乗の注意  偶数乗した場合負の数が正になる   ビットシフト演算子の計算順序  遅め(1\u0026laquo;2+2は1\u0026laquo;4で16になる)    ","permalink":"https://shibaken28.github.io/my-blog/post/kyopro/wa/","summary":"前提  コンパイルするファイルが間違っている 実行するファイルが間違っている コンパイルに失敗し，前回コンパイル成功時のファイルを実行している  コンパイルできない  ヘッダがない  人のコードパクってきたときにfuncional.hがなかった   using namespaceがない 変数名とdefineの重複 vector\u0026lt;vector\u0026lt;long\u0026gt;\u0026gt; A(N,vector\u0026lt;int\u0026gt;(0))みたいに型が一致していない \u0026lt;Templete T\u0026gt;の書き忘れ  コーナーケース  N=1,K=0などの極端な値 A=Bのとき 同じクエリが複数回来るかもしれない 自己ループ，同じ辺 0の0乗  実行が終わらない  入力を受け取りすぎている  クエリの数Qと要素数Nが混同してしまう   n重for文でインクリメントする変数を間違える n重for文で変数名が重複 計算量が多い  setに要素を大量に入れている可能性    セグフォ  cinを忘れている 二項係数ライブラリとかの前計算した配列の範囲外参照 文字列の操作中に空文字が登場する 0,1-indexedの混同  その他ハマり modを正しく取れていない  modを取ってない mod(法)の値が間違っている(998244353,1e9+7) modの取り方を間違っている  法が素数でない，逆元が存在しない mod 3とかでの二項係数はルーカスの定理を使う   modを取りながら累積和したときに負の数がでる  (A[r]-A[l-1]+mod)%mod みたいな配慮   最後にマイナス1などをしている(0のときに-1が出力されてしまう)  未分類  改行(flush)しないと標準出力にでてこない cin\u0026raquo;a,b;みたいなことをしている  エラーが出ないことがあるのでハマりやすい   switch文でbreak忘れ make clean 型のパース，intをlongの計算にそのまま突っ込むのは良くない コンストラクタの名前を間違えている 閉区間，半開区間などの違い setやmapでstd::lower_boundなどは使えない  メソッドとして用意されている   01ナップザックで昇順にdpを回してしまった  それは個数制限なし   bool型をint型だと思って  bool値に2以上を入れてもサイレントに1になる   ソート後の配列をソート前の状態として扱ってしまった 格子点とグリッドマス目の関係  角の座標の扱い   不等式における累乗の注意  偶数乗した場合負の数が正になる   ビットシフト演算子の計算順序  遅め(1\u0026laquo;2+2は1\u0026laquo;4で16になる)    ","title":"競プロでのやらかし"},{"content":"はじめに TSG lIVE! 8 CTFにチーム参加しました． crypto問を3問中2つ解いたのでwriteupを書きます．\nForgetful RSA flagの上位$i$bitを$f_i$と表すことにする．また，$f_i^e \\mod n =c_i$とする． 出力された配列cを見ると，小さい$i$について$f_i^e\u0026lt;n$であり，$f_i^e = c_i$予想できる．\n(f_4)**e = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 (f_3)**e = 43180842775472231269317593140019978555800018221814069251185173508429590158121352898575375173614411328027364697307483179849754947341597334682650188852903738734312355518341064453125 (f_2)**e = 231584178474632390847141970017375815706539969331281128078915168015826259279872 (f_1)**e = 1 例えば，次のようにプログラムを掛けば\n\u0026gt;\u0026gt;\u0026gt; from gmpy2 import iroot \u0026gt;\u0026gt;\u0026gt; e = 0x101 \u0026gt;\u0026gt;\u0026gt; c = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 \u0026gt;\u0026gt;\u0026gt; iroot(c,e) (mpz(10), True) \u0026gt;\u0026gt;\u0026gt; flagの上位4bitが0b1010であることがわかる．\n次に，最大公約数をうまく使うことで$n$を求める． $f_5^e n=c_5\\mod n$より，$f_5^e - c_5 = 0 \\mod n$で，$f_5^e -c_5$は$n$の倍数である． 同様に，$f_6^e - c_6$も$n$の倍数であるから，これらの最大公約数をとることで$n$が得られる． $f_5$，$f_6$として考えられる値はたかだか$4$通りであるため，全て試せばいい．\nfrom Crypto.Util.number import GCD c.reverse() a0 = pow(0b10100,e) a1 = pow(0b10101,e) a00 = pow(0b101000,e) a01 = pow(0b101001,e) a10 = pow(0b101010,e) a11 = pow(0b101011,e) print(GCD(a0-c[5],a00-c[6])) print(GCD(a0-c[5],a01-c[6])) print(GCD(a1-c[5],a10-c[6])) print(GCD(a1-c[5],a11-c[6])) 結果は以下の通りである．\n1 1 142643935303446381001279947550591766064860638332732560752396406069081171879061311344991121502015387733157095870331363131417418514982044480403293728339899298554597845932712399673486772631075556012586672082574811346123474551631303197292734503133958141848155519486123242876455089596670804942778448421334181752913 2 これにより，3行目が$n$の値とわかる．\nあとは，フラグを1bitずつ伸ばしていって，各$c_i$の値と一致するかを確認していけばよい．\nfrom Crypto.Util.number import long_to_bytes  e = 0x101 n = 142643935303446381001279947550591766064860638332732560752396406069081171879061311344991121502015387733157095870331363131417418514982044480403293728339899298554597845932712399673486772631075556012586672082574811346123474551631303197292734503133958141848155519486123242876455089596670804942778448421334181752913 c.reverse()  m = 0 for i in range(len(c)):  if i==0:  continue  if pow(m*2,e,n)==c[i]:  m = m*2+0  if pow(m*2+1,e,n)==c[i]:  m = m*2+1  print(long_to_bytes(m)) b\u0026#39;TSGLIVE{mY_m3MoRy-m4y_Impr0ve_s0me_D4y..._b1t_by_6it!}\u0026#39; Two Keys $p$のnextPrimeを$p+a$，$q$のnextPrimeを$q+b$とおく． 各$n$を次のように表すことにする． $$n_1=pq, \\quad n_2 =(p+a)(q+b)$$ $n_2$は，$n_1$を使って表すことができる． $$n_2 = pq + pb + qa + ab = n_1 + pb + qa + ab$$ また，$n_1=pq$より，$q=\\frac{n_1}{p}$を代入． $$n_2 = n_1 + pb + a\\frac{n_1}{p}+ab$$ 両辺を，$p$倍． $$pn_2 = pn_1 + p^2 b + an_1+pab$$ 整理する． $$p^2b + p(n_1-n_2+ab) + an_1=0$$ これにより，$p$に関する二次方程式ができる．$a$と$b$は素数間の距離であり，あまり大きくならないと考えられるため，適当な値で探索する．\nN1 = 56857358946783738817465975297711204069935415016419932538392922530218921201217352346494361968035470184308357037387164930109496691365401965670237349367799774405061235025947852274083877022468072607753900481316564650009744632767993278947752127202134753913008582254000854930780954253903124752186965795809304941831 N2 = 56857358946783738817465975297711204069935415016419932538392922530218921201217352346494361968035470184308357037387164930109496691365401965670237349367805332556208545324190423359112543995138089627600000504956531406110700016755090783444147649357626603184673602899015609448577621960908326053341685493162553923683  from gmpy2 import iroot from Crypto.Util.number import *  for a in range(1,1000):  for b in range(1,1000):  A = b  B = N1 - N2 + a*b  C = a * N1  D = B*B-4*A*C  if D\u0026lt;0:  continue  D,t=iroot(D,2)  if t:  X1 =(-B+D )//(2*A)  X2 =(-B-D )//(2*A)  if N1%X1 == 0:  print(X1)  if N1%X2 == 0:  print(X1) これで$p$が得られる．\n7180400826431487264888758121573735514382183735722336320585544657738663184707542134001295421874439992397088282386645899023064682034148882357611433798725561 各パラメータを計算し，フラグが求まる．\nTSGLIVE{pr1M3_numb3R5_4R3_pR377y_d3N53_1M0} 感想 twokeysも解ける問題だったので時間オーバーして悔しかったです．問題がとても面白かったです．\n","permalink":"https://shibaken28.github.io/my-blog/post/ctf/crypto/tsg8/all/","summary":"はじめに TSG lIVE! 8 CTFにチーム参加しました． crypto問を3問中2つ解いたのでwriteupを書きます．\nForgetful RSA flagの上位$i$bitを$f_i$と表すことにする．また，$f_i^e \\mod n =c_i$とする． 出力された配列cを見ると，小さい$i$について$f_i^e\u0026lt;n$であり，$f_i^e = c_i$予想できる．\n(f_4)**e = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 (f_3)**e = 43180842775472231269317593140019978555800018221814069251185173508429590158121352898575375173614411328027364697307483179849754947341597334682650188852903738734312355518341064453125 (f_2)**e = 231584178474632390847141970017375815706539969331281128078915168015826259279872 (f_1)**e = 1 例えば，次のようにプログラムを掛けば\n\u0026gt;\u0026gt;\u0026gt; from gmpy2 import iroot \u0026gt;\u0026gt;\u0026gt; e = 0x101 \u0026gt;\u0026gt;\u0026gt; c = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 \u0026gt;\u0026gt;\u0026gt; iroot(c,e) (mpz(10), True) \u0026gt;\u0026gt;\u0026gt; flagの上位4bitが0b1010であることがわかる．\n次に，最大公約数をうまく使うことで$n$を求める． $f_5^e n=c_5\\mod n$より，$f_5^e - c_5 = 0 \\mod n$で，$f_5^e -c_5$は$n$の倍数である． 同様に，$f_6^e - c_6$も$n$の倍数であるから，これらの最大公約数をとることで$n$が得られる． $f_5$，$f_6$として考えられる値はたかだか$4$通りであるため，全て試せばいい．\nfrom Crypto.Util.number import GCD c.reverse() a0 = pow(0b10100,e) a1 = pow(0b10101,e) a00 = pow(0b101000,e) a01 = pow(0b101001,e) a10 = pow(0b101010,e) a11 = pow(0b101011,e) print(GCD(a0-c[5],a00-c[6])) print(GCD(a0-c[5],a01-c[6])) print(GCD(a1-c[5],a10-c[6])) print(GCD(a1-c[5],a11-c[6])) 結果は以下の通りである．","title":"TSG lIVE! 8 CTFに参加しました"},{"content":"LSB Decryption Oracle Attack RSA暗号において，何度も暗号文を復元してくれて，その最も下のビットがわかっている場合，LSB Decryption Oracle Attackが使える． ここでは，入力$x$に対して，$x^d\\mod n$が出力されるものとする． (RSAの各パラメータの説明については省略する．)\n理論 $$(2m)^e = 2^em^e = 2^ec\\mod n$$ が成り立つため，$2^ec\\mod n$を入力として与えると，$(2m)^e\\mod n$を復元することになるため，$2m \\mod n$が返ってくる． この値の偶奇で$m$の範囲がわかる．\n もし，$0\\leq2m\u0026lt;n$の場合，$2m\\mod n$と$2m$は等しいため，$2m \\mod n$は必ず偶数になる． もし，$n\\leq2m\u0026lt;2n$の場合，$2m\\mod n$は$2m-n$と等しいため，$n$が奇数であることから$2m\\mod n$は必ず奇数になる．  $0\u0026lt;m\u0026lt;n$であるから，$2m$がこれ以外の値の範囲をとることはない． これにより，$2m\\mod n$が偶数なら$0\\leq m\u0026lt;\\frac{1}{2}n$，奇数なら$\\frac{1}{2}n\\leq m\u0026lt;n$であることがわかる．\n次に，$4^ec\\mod n$を入力に与えることについて考える．同様に，$4^ec = (4m)^c\\mod n$が成り立つから，$4m\\mod n$の値が返ってくる． 例えば，$2m\\mod n$の出力が偶数で，$0\\leq m\u0026lt;\\frac{1}{2}n$であることが，わかっていたとする．このとき，$4m\\mod n$の偶奇は次のように決まっている．\n $0\\leq4m\u0026lt;n$の場合，$4m\\mod n$は$4m$と等しいため，$4m\\mod n$は必ず偶数になる． $n\\leq4m\u0026lt;2n$の場合，$4m\\mod n$は$4m-n$と等しいため，$4m\\mod n$は必ず奇数になる．  よって，$2m\\mod n$が偶数で， かつ$4m\\mod n$が偶数のときは，$0\\leq m\u0026lt;\\frac{1}{4}n$，奇数のときは$\\frac{1}{4}n\\leq m\u0026lt;\\frac{1}{2}n$であることがわかる．\n同様に，$2m\\mod n$の出力が奇数で，$\\frac{1}{2}n\\leq m\u0026lt;n$であることが，わかっていたとする．このとき，$4m\\mod n$の偶奇は次のように決まっている．\n $2n\\leq4m\u0026lt;3n$の場合，$4m\\mod n$は$4m-2n$と等しいため，$4m\\mod n$は必ず偶数になる． $3n\\leq4m\u0026lt;4n$の場合，$4m\\mod n$は$4m-3n$と等しいため，$4m\\mod n$は必ず奇数になる．  よって，$2m\\mod n$が奇数で， かつ$4m\\mod n$が偶数のときは，$\\frac{1}{2}n\\leq m\u0026lt;\\frac{3}{4}n$，奇数のときは$\\frac{3}{4}n\\leq m\u0026lt;n$であることがわかる．\nこれを繰り返していくと，二分探索の要領でどんどん$m$の取りうる値が半分になっていき，最終的に$m$の値が求まる．\n実装例 整数でl,rを動かすと誤差が出てしまうため，有理数を使っている．\nfrom Crypto.Util.number import * from fractions import Fraction from math import ceil  p = getPrime(256) q = getPrime(256) n = p*q m = bytes_to_long(b\u0026#34;flag{this_is_flag}\u0026#34;) e = 0x10001 c = pow(m,e,n) d = pow(e,-1,(p-1)*(q-1)) assert m\u0026lt;n assert pow(c,d,n)==m  def dec(x):  return pow(x,d,n)  l = 0 r = n a = 1 while abs(r-l)\u0026gt;1:  b=(c*pow(2,a*e,n))%n  de = dec(b)  mid = Fraction(l + r, 2)  if de%2==0:  r = mid  else:  l = mid  a+=1 print(ceil(l)) print(m) 参考サイト  plain RSAに対するLSB decryption oracle attackをやってみる LSB Leak Attackを実装した  を参考にさせて頂きました．\n","permalink":"https://shibaken28.github.io/my-blog/post/ctf/crypto/script/lsb/","summary":"LSB Decryption Oracle Attack RSA暗号において，何度も暗号文を復元してくれて，その最も下のビットがわかっている場合，LSB Decryption Oracle Attackが使える． ここでは，入力$x$に対して，$x^d\\mod n$が出力されるものとする． (RSAの各パラメータの説明については省略する．)\n理論 $$(2m)^e = 2^em^e = 2^ec\\mod n$$ が成り立つため，$2^ec\\mod n$を入力として与えると，$(2m)^e\\mod n$を復元することになるため，$2m \\mod n$が返ってくる． この値の偶奇で$m$の範囲がわかる．\n もし，$0\\leq2m\u0026lt;n$の場合，$2m\\mod n$と$2m$は等しいため，$2m \\mod n$は必ず偶数になる． もし，$n\\leq2m\u0026lt;2n$の場合，$2m\\mod n$は$2m-n$と等しいため，$n$が奇数であることから$2m\\mod n$は必ず奇数になる．  $0\u0026lt;m\u0026lt;n$であるから，$2m$がこれ以外の値の範囲をとることはない． これにより，$2m\\mod n$が偶数なら$0\\leq m\u0026lt;\\frac{1}{2}n$，奇数なら$\\frac{1}{2}n\\leq m\u0026lt;n$であることがわかる．\n次に，$4^ec\\mod n$を入力に与えることについて考える．同様に，$4^ec = (4m)^c\\mod n$が成り立つから，$4m\\mod n$の値が返ってくる． 例えば，$2m\\mod n$の出力が偶数で，$0\\leq m\u0026lt;\\frac{1}{2}n$であることが，わかっていたとする．このとき，$4m\\mod n$の偶奇は次のように決まっている．\n $0\\leq4m\u0026lt;n$の場合，$4m\\mod n$は$4m$と等しいため，$4m\\mod n$は必ず偶数になる． $n\\leq4m\u0026lt;2n$の場合，$4m\\mod n$は$4m-n$と等しいため，$4m\\mod n$は必ず奇数になる．  よって，$2m\\mod n$が偶数で， かつ$4m\\mod n$が偶数のときは，$0\\leq m\u0026lt;\\frac{1}{4}n$，奇数のときは$\\frac{1}{4}n\\leq m\u0026lt;\\frac{1}{2}n$であることがわかる．\n同様に，$2m\\mod n$の出力が奇数で，$\\frac{1}{2}n\\leq m\u0026lt;n$であることが，わかっていたとする．このとき，$4m\\mod n$の偶奇は次のように決まっている．\n $2n\\leq4m\u0026lt;3n$の場合，$4m\\mod n$は$4m-2n$と等しいため，$4m\\mod n$は必ず偶数になる． $3n\\leq4m\u0026lt;4n$の場合，$4m\\mod n$は$4m-3n$と等しいため，$4m\\mod n$は必ず奇数になる．  よって，$2m\\mod n$が奇数で， かつ$4m\\mod n$が偶数のときは，$\\frac{1}{2}n\\leq m\u0026lt;\\frac{3}{4}n$，奇数のときは$\\frac{3}{4}n\\leq m\u0026lt;n$であることがわかる．","title":"LSB Decryption Oracle Attackの実装"},{"content":"概要 What if d is too small? Connect with nc mercury.picoctf.net 36463.\nncの内容\nWelcome to my RSA challenge! e: 103624928593399333320247354911447965825264533650971057319298353304002525474538065318852403512064726461174738193603428106904946146256008284823467554827152762569423678591697957603893052975071382627033744303434383276450203293997261442427812721673950613659922998042873117563940092261133781695925987694748389771773 n: 103910376399608681676353628245393162112102881564697113185356793045870832553995623283598951790023021111968530063336394918465350791877495297372970778126616798657973881785284282419987615918907108230154026098524221387899079560549181123756630931610952760466877749364644405065649111649647375141195338190881890507223 c: 30156643564028622673402640319494318578298751067165305755816959327117523569994850417236902775720256626905433978437761494210359833045159937002407287756120449107903682641130585193469930881110966314401974180644201866961482046321797331181951910878959864017526708803440621343824946268602601257095502437975774863711 解答 eが大きいということは，dが小さくなるので，Wiener\u0026rsquo;s attackが有効． Wiener\u0026rsquo;s attack 短い秘密鍵のRSA暗号への攻撃を参考にさせて頂きました．\nfrom Crypto.Util.number import long_to_bytes  #Welcome to my RSA challenge! e= 103624928593399333320247354911447965825264533650971057319298353304002525474538065318852403512064726461174738193603428106904946146256008284823467554827152762569423678591697957603893052975071382627033744303434383276450203293997261442427812721673950613659922998042873117563940092261133781695925987694748389771773 n= 103910376399608681676353628245393162112102881564697113185356793045870832553995623283598951790023021111968530063336394918465350791877495297372970778126616798657973881785284282419987615918907108230154026098524221387899079560549181123756630931610952760466877749364644405065649111649647375141195338190881890507223 c= 30156643564028622673402640319494318578298751067165305755816959327117523569994850417236902775720256626905433978437761494210359833045159937002407287756120449107903682641130585193469930881110966314401974180644201866961482046321797331181951910878959864017526708803440621343824946268602601257095502437975774863711   def f(a, b):  q, r = a//b, a%b  a0, a1 = 1, q  b0, b1 = 0, 1  while r:  a, b = b, r  q, r = a//b, a%b  a0, a1 = a1, a0 + q*a1  b0, b1 = b1, b0 + q*b1  print(long_to_bytes(pow(c,b1,n)))  f(e,n) このまま実行すると，正しくないdについてもたくさん出力されるので，grep picoなどでフラグを探す．\npython3 solve.py | grep pico b\u0026#39;picoCTF{proving_wiener_2635457}\u0026#39; ","permalink":"https://shibaken28.github.io/my-blog/post/ctf/crypto/pico/dachshund-attacks/","summary":"概要 What if d is too small? Connect with nc mercury.picoctf.net 36463.\nncの内容\nWelcome to my RSA challenge! e: 103624928593399333320247354911447965825264533650971057319298353304002525474538065318852403512064726461174738193603428106904946146256008284823467554827152762569423678591697957603893052975071382627033744303434383276450203293997261442427812721673950613659922998042873117563940092261133781695925987694748389771773 n: 103910376399608681676353628245393162112102881564697113185356793045870832553995623283598951790023021111968530063336394918465350791877495297372970778126616798657973881785284282419987615918907108230154026098524221387899079560549181123756630931610952760466877749364644405065649111649647375141195338190881890507223 c: 30156643564028622673402640319494318578298751067165305755816959327117523569994850417236902775720256626905433978437761494210359833045159937002407287756120449107903682641130585193469930881110966314401974180644201866961482046321797331181951910878959864017526708803440621343824946268602601257095502437975774863711 解答 eが大きいということは，dが小さくなるので，Wiener\u0026rsquo;s attackが有効． Wiener\u0026rsquo;s attack 短い秘密鍵のRSA暗号への攻撃を参考にさせて頂きました．\nfrom Crypto.Util.number import long_to_bytes  #Welcome to my RSA challenge! e= 103624928593399333320247354911447965825264533650971057319298353304002525474538065318852403512064726461174738193603428106904946146256008284823467554827152762569423678591697957603893052975071382627033744303434383276450203293997261442427812721673950613659922998042873117563940092261133781695925987694748389771773 n= 103910376399608681676353628245393162112102881564697113185356793045870832553995623283598951790023021111968530063336394918465350791877495297372970778126616798657973881785284282419987615918907108230154026098524221387899079560549181123756630931610952760466877749364644405065649111649647375141195338190881890507223 c= 30156643564028622673402640319494318578298751067165305755816959327117523569994850417236902775720256626905433978437761494210359833045159937002407287756120449107903682641130585193469930881110966314401974180644201866961482046321797331181951910878959864017526708803440621343824946268602601257095502437975774863711   def f(a, b):  q, r = a//b, a%b  a0, a1 = 1, q  b0, b1 = 0, 1  while r:  a, b = b, r  q, r = a//b, a%b  a0, a1 = a1, a0 + q*a1  b0, b1 = b1, b0 + q*b1  print(long_to_bytes(pow(c,b1,n)))  f(e,n) このまま実行すると，正しくないdについてもたくさん出力されるので，grep picoなどでフラグを探す．","title":"picoGym - Dachshund Attacks"},{"content":"概要 We found a brand new type of encryption, can you break the secret code? (Wrap with picoCTF{})\nmlnklfnknljflfmhjimkmhjhmljhjomhmmjkjpmmjmjkjpjojgjmjpjojojnjojmmkmlmijimhjmmj import string  LOWERCASE_OFFSET = ord(\u0026#34;a\u0026#34;) ALPHABET = string.ascii_lowercase[:16]  def b16_encode(plain): \tenc = \u0026#34;\u0026#34; \tfor c in plain: \tbinary = \u0026#34;{0:08b}\u0026#34;.format(ord(c)) \tenc += ALPHABET[int(binary[:4], 2)] \tenc += ALPHABET[int(binary[4:], 2)] \treturn enc  def shift(c, k): \tt1 = ord(c) - LOWERCASE_OFFSET \tt2 = ord(k) - LOWERCASE_OFFSET \treturn ALPHABET[(t1 + t2) % len(ALPHABET)]  flag = \u0026#34;redacted\u0026#34; key = \u0026#34;redacted\u0026#34; assert all([k in ALPHABET for k in key]) assert len(key) == 1  b16 = b16_encode(flag) enc = \u0026#34;\u0026#34; for i, c in enumerate(b16): \tenc += shift(c, key[i % len(key)]) print(enc) 解答 フラグは，b16_encode，shiftの順に，2段階でエンコードされているので，逆順にデコードしていく． shiftに関しては，assertの条件により，せいぜい16通りである．\nimport string  LOWERCASE_OFFSET = ord(\u0026#34;a\u0026#34;) ALPHABET = string.ascii_lowercase[:16]  def b16_decode(cipher):  plain = \u0026#34;\u0026#34;  i = 0  while i\u0026lt;len(cipher):  plain += chr((ord(cipher[i])-LOWERCASE_OFFSET)\u0026lt;\u0026lt;4)+ord(cipher[i+1])-LOWERCASE_OFFSET)  i+=2  return plain  def shift_rev(c, k): \tt1 = ord(c) - LOWERCASE_OFFSET \tt2 = ord(k) - LOWERCASE_OFFSET \treturn ALPHABET[(t1 - t2 + len(ALPHABET)) % len(ALPHABET)]  enc = \u0026#34;mlnklfnknljflfmhjimkmhjhmljhjomhmmjkjpmmjmjkjpjojgjmjpjojojnjojmmkmlmijimhjmmj\u0026#34;  for k in ALPHABET:  current_enc = \u0026#34;\u0026#34;  for c in enc:  current_enc+=shift_rev(c,k)  print(k,\u0026#34;:\u0026#34;,b16_decode(current_enc)) 結果であるが，フラグっぽい文字列が見つからない．\na : ËÚµÚÛµÇÇËÌÊËÈÉ b : ºÉ¤ÉÊ ¤¶¹¶º¶»» ¹º·¶¸ c : ©¸¸¹s¥v¨¥u©u|¥ªx}ªzx}|tz}||{|z¨©¦v¥z§ d : §¨bedgliglkcilkkjkiei e : qQqTSSZV[XV[ZRX[ZZYZX TX f : v ` @`rCurBvBIrwEJwGEJIAGJIIHIGuvsCrGt g : et_tu?_a2da1e18af49f649806988786deb2a6c h : TcNcd.NP!SP T \u0026#39;PU#(U%#(\u0026#39;/%(\u0026#39;\u0026#39;\u0026amp;\u0026#39;%STQ!P%R i : CR=RS\\x1dO\\x10O\\x1f\\x1fOD\\x12D\\x14\\x17\\x1e\\x17\\x16\\x16BC@\\x10\\x14 \\x03\\x05\\x04\\x032?\\x0f\\x03 k : !0\\x1b01û\\x1b-þ -ý!ýô-\u0026#34;ðõ\u0026#34;òðõôüòõôôóôò !.þ-ò/ l : \\x10 / ê \\x1c\\xad\\x1fì\\x10\\xacã\\x1cïä\\x11\\xa1ïäãëáäããâãá\\x1f\\x1d\\xad\\x1c\\xa1\\x1e \\x0e\\x88èúËýúÊþÊÁúÿÍÂÿÏÍÂÁÉÏÂÁÁÀÁÏýþûËúÏü o : íü×üý·×éºìé¹í¹°éî¼±î¾¼±°¸¾±°°¿°¾ìíêºé¾ë p : ÜëÆëì¦ÆØ©ÛØ¨Ü¨¯ØÝ« Ý­« ¯§­ ¯¯®¯­ÛÜÙ©Ø­Ú 実装を間違えてことを疑うが，検証してみるとそうでもなさそう． 実は，picoCTF{et_tu?_a2da1e18af49f649806988786deb2a6c}がフラグである． 実際に，keyを指定して実行するとmlnklfnknl(以下略)が出力される．\n余談 picoGymにはgoodとbadの評価ができるボタンがありますが，こういうフラグが間違いに見える問題の評価はあまり高くないですね．\n","permalink":"https://shibaken28.github.io/my-blog/post/ctf/crypto/pico/new-ceaser/","summary":"概要 We found a brand new type of encryption, can you break the secret code? (Wrap with picoCTF{})\nmlnklfnknljflfmhjimkmhjhmljhjomhmmjkjpmmjmjkjpjojgjmjpjojojnjojmmkmlmijimhjmmj import string  LOWERCASE_OFFSET = ord(\u0026#34;a\u0026#34;) ALPHABET = string.ascii_lowercase[:16]  def b16_encode(plain): \tenc = \u0026#34;\u0026#34; \tfor c in plain: \tbinary = \u0026#34;{0:08b}\u0026#34;.format(ord(c)) \tenc += ALPHABET[int(binary[:4], 2)] \tenc += ALPHABET[int(binary[4:], 2)] \treturn enc  def shift(c, k): \tt1 = ord(c) - LOWERCASE_OFFSET \tt2 = ord(k) - LOWERCASE_OFFSET \treturn ALPHABET[(t1 + t2) % len(ALPHABET)]  flag = \u0026#34;redacted\u0026#34; key = \u0026#34;redacted\u0026#34; assert all([k in ALPHABET for k in key]) assert len(key) == 1  b16 = b16_encode(flag) enc = \u0026#34;\u0026#34; for i, c in enumerate(b16): \tenc += shift(c, key[i % len(key)]) print(enc) 解答 フラグは，b16_encode，shiftの順に，2段階でエンコードされているので，逆順にデコードしていく． shiftに関しては，assertの条件により，せいぜい16通りである．","title":"picoGym - New Ceaser"},{"content":"概要 A one-time pad is unbreakable, but can you manage to recover the flag? (Wrap with picoCTF{}) nc mercury.picoctf.net 64260 otp.py\n#!/usr/bin/python3 -u import os.path  KEY_FILE = \u0026#34;key\u0026#34; KEY_LEN = 50000 FLAG_FILE = \u0026#34;flag\u0026#34;   def startup(key_location): \tflag = open(FLAG_FILE).read() \tkf = open(KEY_FILE, \u0026#34;rb\u0026#34;).read()  \tstart = key_location \tstop = key_location + len(flag)  \tkey = kf[start:stop] \tkey_location = stop  \tresult = list(map(lambda p, k: \u0026#34;{:02x}\u0026#34;.format(ord(p) ^ k), flag, key)) \tprint(\u0026#34;This is the encrypted flag!\\n{}\\n\u0026#34;.format(\u0026#34;\u0026#34;.join(result)))  \treturn key_location  def encrypt(key_location): \tui = input(\u0026#34;What data would you like to encrypt? \u0026#34;).rstrip() \tif len(ui) == 0 or len(ui) \u0026gt; KEY_LEN: \treturn -1  \tstart = key_location \tstop = key_location + len(ui)  \tkf = open(KEY_FILE, \u0026#34;rb\u0026#34;).read()  \tif stop \u0026gt;= KEY_LEN: \tstop = stop % KEY_LEN \tkey = kf[start:] + kf[:stop] \telse: \tkey = kf[start:stop] \tkey_location = stop  \tresult = list(map(lambda p, k: \u0026#34;{:02x}\u0026#34;.format(ord(p) ^ k), ui, key))  \tprint(\u0026#34;Here ya go!\\n{}\\n\u0026#34;.format(\u0026#34;\u0026#34;.join(result)))  \treturn key_location   print(\u0026#34;******************Welcome to our OTP implementation!******************\u0026#34;) c = startup(0) while c \u0026gt;= 0: \tc = encrypt(c) 解答 裏で何が行われているかを見る． 長さ50000のkeyが用意されていて，key_locationが0にセットされている． 入力があると，keyのkey_location文字目から，その入力の文字数文だけが取り出され，XORされる．そして，key_locationはその文字数分だけ動く．\nxorの性質より，50000文字の入力を与えて，出力を得れば，keyがわかる． 特に，文字コード0\\x00を50000文字連ねれば，そのままkeyが出力される．\n次のスクリプトでは，50000-(フラグ長)の分だけkey_locationを動かして，次の入力でちょうどフラグとxorされた値が出力されるようにしている．\nfrom pwn import *  io = remote(\u0026#34;mercury.picoctf.net\u0026#34;,64260)  S = io.recvuntil(\u0026#34;?\u0026#34;).decode() print(\u0026#34;[+] \u0026#34;,S)  KEY_LEN = 50000 FLAG_LEN = len(\u0026#34;51466d4e5f575538195551416e4f5300413f1b5008684d5504384157046e4959\u0026#34;)//2 out = b\u0026#34;\\x00\u0026#34; * (KEY_LEN-FLAG_LEN) io.sendline(out) io.recvuntil(\u0026#34;?\u0026#34;).decode()  out = b\u0026#34;\\x00\u0026#34; * FLAG_LEN io.sendline(out) S = io.recvuntil(\u0026#34;?\u0026#34;).decode() print(\u0026#34;[+] \u0026#34;,S) [+] Opening connection to mercury.picoctf.net on port 64260: Done solve.py:8: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes S = io.recvuntil(\u0026#34;?\u0026#34;).decode() [+] ******************Welcome to our OTP implementation!****************** This is the encrypted flag! 51466d4e5f575538195551416e4f5300413f1b5008684d5504384157046e4959 What data would you like to encrypt? solve.py:15: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes io.recvuntil(\u0026#34;?\u0026#34;).decode() solve.py:19: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes S = io.recvuntil(\u0026#34;?\u0026#34;).decode() [+] Here ya go! 62275c786663615c783165725c786237225c7863315c7831375c7861305c7838 これにより，次の関係がわかる．\nkey = 62275c786663615c783165725c786237225c7863315c7831375c7861305c7838 flag ^ key = 51466d4e5f575538195551416e4f5300413f1b5008684d5504384157046e4959 \u0026gt;\u0026gt;\u0026gt; a = 0x51466d4e5f575538195551416e4f5300413f1b5008684d5504384157046e4959 ^ 0x62275c786663615c783165725c786237225c7863315c7831375c7861305c7838 \u0026gt;\u0026gt;\u0026gt; from Crypto.Util.number import long_to_bytes \u0026gt;\u0026gt;\u0026gt; long_to_bytes(a) b\u0026#39;3a16944dad432717ccc3945d3d96421a\u0026#39; 数字の羅列が出てきて，失敗したように見えるが，実はこれがそのままpicoCTF{3a16944dad432717ccc3945d3d96421a}とフラグになる．\n感想 間違いだと勘違いするので，フラグの内容は意味のある文字列にしてほしいです！\n","permalink":"https://shibaken28.github.io/my-blog/post/ctf/crypto/pico/easy-peasy/","summary":"概要 A one-time pad is unbreakable, but can you manage to recover the flag? (Wrap with picoCTF{}) nc mercury.picoctf.net 64260 otp.py\n#!/usr/bin/python3 -u import os.path  KEY_FILE = \u0026#34;key\u0026#34; KEY_LEN = 50000 FLAG_FILE = \u0026#34;flag\u0026#34;   def startup(key_location): \tflag = open(FLAG_FILE).read() \tkf = open(KEY_FILE, \u0026#34;rb\u0026#34;).read()  \tstart = key_location \tstop = key_location + len(flag)  \tkey = kf[start:stop] \tkey_location = stop  \tresult = list(map(lambda p, k: \u0026#34;{:02x}\u0026#34;.","title":"picoGym - Easy Peasy"},{"content":"概要 What happens if you have a small exponent? There is a twist though, we padded the plaintext so that (M ** e) is just barely larger than N. Let\u0026rsquo;s decrypt this\nN: 1615765684321463054078226051959887884233678317734892901740763321135213636796075462401950274602405095138589898087428337758445013281488966866073355710771864671726991918706558071231266976427184673800225254531695928541272546385146495736420261815693810544589811104967829354461491178200126099661909654163542661541699404839644035177445092988952614918424317082380174383819025585076206641993479326576180793544321194357018916215113009742654408597083724508169216182008449693917227497813165444372201517541788989925461711067825681947947471001390843774746442699739386923285801022685451221261010798837646928092277556198145662924691803032880040492762442561497760689933601781401617086600593482127465655390841361154025890679757514060456103104199255917164678161972735858939464790960448345988941481499050248673128656508055285037090026439683847266536283160142071643015434813473463469733112182328678706702116054036618277506997666534567846763938692335069955755244438415377933440029498378955355877502743215305768814857864433151287 e: 3 ciphertext (c): 1220012318588871886132524757898884422174534558055593713309088304910273991073554732659977133980685370899257850121970812405700793710546674062154237544840177616746805668666317481140872605653768484867292138139949076102907399831998827567645230986345455915692863094364797526497302082734955903755050638155202890599808146956044568639690002921620304969196755223769438221859424275683828638207433071955615349052424040706261639770492033970498727183446507482899334169592311953247661557664109356372049286283480939368007035616954029177541731719684026988849403756133033533171081378815289443019437298879607294287249591634702823432448559878065453908423094452047188125358790554039587941488937855941604809869090304206028751113018999782990033393577325766685647733181521675994939066814158759362046052998582186178682593597175186539419118605277037256659707217066953121398700583644564201414551200278389319378027058801216150663695102005048597466358061508725332471930736629781191567057009302022382219283560795941554288119544255055962 RSAの問題．$m^e$が$n$よりほんのすこしだけ大きいようである．\n解答 $c = m^e =m^3 \\mod n$は，等式に変形すると，整数$k$を使って次のように表せる． $$m^3 = c + kn$$ $m^e$が$n$よりほんの少しだけ大きいということは，整数$k$は小さいということである． つまり，$k=1,2,3,4,\u0026hellip;$と順に探索していき，$m^3$となる，すなわち3乗根が整数となる値を見つければ良い． 3乗根は，2分探索で求めることができるが，gmpy2のirootを使うと楽である．\nfrom pwn import * from Crypto.Util.number import long_to_bytes from gmpy2 import iroot   n = 1615765684321463054078226051959887884233678317734892901740763321135213636796075462401950274602405095138589898087428337758445013281488966866073355710771864671726991918706558071231266976427184673800225254531695928541272546385146495736420261815693810544589811104967829354461491178200126099661909654163542661541699404839644035177445092988952614918424317082380174383819025585076206641993479326576180793544321194357018916215113009742654408597083724508169216182008449693917227497813165444372201517541788989925461711067825681947947471001390843774746442699739386923285801022685451221261010798837646928092277556198145662924691803032880040492762442561497760689933601781401617086600593482127465655390841361154025890679757514060456103104199255917164678161972735858939464790960448345988941481499050248673128656508055285037090026439683847266536283160142071643015434813473463469733112182328678706702116054036618277506997666534567846763938692335069955755244438415377933440029498378955355877502743215305768814857864433151287 e = 3 c = 1220012318588871886132524757898884422174534558055593713309088304910273991073554732659977133980685370899257850121970812405700793710546674062154237544840177616746805668666317481140872605653768484867292138139949076102907399831998827567645230986345455915692863094364797526497302082734955903755050638155202890599808146956044568639690002921620304969196755223769438221859424275683828638207433071955615349052424040706261639770492033970498727183446507482899334169592311953247661557664109356372049286283480939368007035616954029177541731719684026988849403756133033533171081378815289443019437298879607294287249591634702823432448559878065453908423094452047188125358790554039587941488937855941604809869090304206028751113018999782990033393577325766685647733181521675994939066814158759362046052998582186178682593597175186539419118605277037256659707217066953121398700583644564201414551200278389319378027058801216150663695102005048597466358061508725332471930736629781191567057009302022382219283560795941554288119544255055962  k = 1 while True:  m3 = c + k*n  m , t = iroot(m3,3)  # mに3乗根(整数)，tにm^3==m3のbool値が返る  if t:  print(long_to_bytes(m))  break  k+=1 余分な空白が入っているフラグが出る．\nb\u0026#39; picoCTF{e_sh0u1d_b3_lArg3r_6e2e6bda}\u0026#39; ","permalink":"https://shibaken28.github.io/my-blog/post/ctf/crypto/pico/mini-rsa/","summary":"概要 What happens if you have a small exponent? There is a twist though, we padded the plaintext so that (M ** e) is just barely larger than N. Let\u0026rsquo;s decrypt this\nN: 1615765684321463054078226051959887884233678317734892901740763321135213636796075462401950274602405095138589898087428337758445013281488966866073355710771864671726991918706558071231266976427184673800225254531695928541272546385146495736420261815693810544589811104967829354461491178200126099661909654163542661541699404839644035177445092988952614918424317082380174383819025585076206641993479326576180793544321194357018916215113009742654408597083724508169216182008449693917227497813165444372201517541788989925461711067825681947947471001390843774746442699739386923285801022685451221261010798837646928092277556198145662924691803032880040492762442561497760689933601781401617086600593482127465655390841361154025890679757514060456103104199255917164678161972735858939464790960448345988941481499050248673128656508055285037090026439683847266536283160142071643015434813473463469733112182328678706702116054036618277506997666534567846763938692335069955755244438415377933440029498378955355877502743215305768814857864433151287 e: 3 ciphertext (c): 1220012318588871886132524757898884422174534558055593713309088304910273991073554732659977133980685370899257850121970812405700793710546674062154237544840177616746805668666317481140872605653768484867292138139949076102907399831998827567645230986345455915692863094364797526497302082734955903755050638155202890599808146956044568639690002921620304969196755223769438221859424275683828638207433071955615349052424040706261639770492033970498727183446507482899334169592311953247661557664109356372049286283480939368007035616954029177541731719684026988849403756133033533171081378815289443019437298879607294287249591634702823432448559878065453908423094452047188125358790554039587941488937855941604809869090304206028751113018999782990033393577325766685647733181521675994939066814158759362046052998582186178682593597175186539419118605277037256659707217066953121398700583644564201414551200278389319378027058801216150663695102005048597466358061508725332471930736629781191567057009302022382219283560795941554288119544255055962 RSAの問題．$m^e$が$n$よりほんのすこしだけ大きいようである．\n解答 $c = m^e =m^3 \\mod n$は，等式に変形すると，整数$k$を使って次のように表せる． $$m^3 = c + kn$$ $m^e$が$n$よりほんの少しだけ大きいということは，整数$k$は小さいということである． つまり，$k=1,2,3,4,\u0026hellip;$と順に探索していき，$m^3$となる，すなわち3乗根が整数となる値を見つければ良い． 3乗根は，2分探索で求めることができるが，gmpy2のirootを使うと楽である．\nfrom pwn import * from Crypto.Util.number import long_to_bytes from gmpy2 import iroot   n = 1615765684321463054078226051959887884233678317734892901740763321135213636796075462401950274602405095138589898087428337758445013281488966866073355710771864671726991918706558071231266976427184673800225254531695928541272546385146495736420261815693810544589811104967829354461491178200126099661909654163542661541699404839644035177445092988952614918424317082380174383819025585076206641993479326576180793544321194357018916215113009742654408597083724508169216182008449693917227497813165444372201517541788989925461711067825681947947471001390843774746442699739386923285801022685451221261010798837646928092277556198145662924691803032880040492762442561497760689933601781401617086600593482127465655390841361154025890679757514060456103104199255917164678161972735858939464790960448345988941481499050248673128656508055285037090026439683847266536283160142071643015434813473463469733112182328678706702116054036618277506997666534567846763938692335069955755244438415377933440029498378955355877502743215305768814857864433151287 e = 3 c = 1220012318588871886132524757898884422174534558055593713309088304910273991073554732659977133980685370899257850121970812405700793710546674062154237544840177616746805668666317481140872605653768484867292138139949076102907399831998827567645230986345455915692863094364797526497302082734955903755050638155202890599808146956044568639690002921620304969196755223769438221859424275683828638207433071955615349052424040706261639770492033970498727183446507482899334169592311953247661557664109356372049286283480939368007035616954029177541731719684026988849403756133033533171081378815289443019437298879607294287249591634702823432448559878065453908423094452047188125358790554039587941488937855941604809869090304206028751113018999782990033393577325766685647733181521675994939066814158759362046052998582186178682593597175186539419118605277037256659707217066953121398700583644564201414551200278389319378027058801216150663695102005048597466358061508725332471930736629781191567057009302022382219283560795941554288119544255055962  k = 1 while True:  m3 = c + k*n  m , t = iroot(m3,3)  # mに3乗根(整数)，tにm^3==m3のbool値が返る  if t:  print(long_to_bytes(m))  break  k+=1 余分な空白が入っているフラグが出る．","title":"picoGym - Mini RSA"},{"content":"picoCTFの過去問が，常設ctfとして楽しめるpicoGymの問題です．\n概要 Class, take your seats! It\u0026#39;s PRIME-time for a quiz... nc jupiter.challenges.picoctf.org 18821 ncすると，RSA暗号の基本知識を問われます．\n解答 基本 この問題を解くにあたって，次の各パラメータの関係を知っておく必要があります．\n$p,q$を素数，$n=pq$とする．また，$e$を適当な正の整数とする． 平文(plaintext)を$m$とすると，暗号文(ciphertext)$c$は $$c = m^e \\mod n$$ で計算され，秘密鍵$d$を $$d = e^{-1} \\mod \\phi(n)$$ と計算すると，平文$m$が $$m = c^d \\mod n$$ で求めることができる． なお，この場合，$\\phi(n) = (p-1)(q-1)$である．\npythonでは，$a^b \\mod c$をpow(a,b,c)で計算することができる($b=-1$でも動作する)．\n解法 1問目 ncすると次のメッセージが表示されます．\nGood morning class! It\u0026#39;s me Ms. Adleman-Shamir-Rivest Today we will be taking a pop quiz, so I hope you studied. Cramming just will not do! You will need to tell me if each example is possible, given your extensive crypto knowledge. Inputs and outputs are in decimal. No hex here! #### NEW PROBLEM #### q : 60413 p : 76753 ##### PRODUCE THE FOLLOWING #### n IS THIS POSSIBLE and FEASIBLE? (Y/N): $p,q$の値が与えられ，$n$を求めることは可能ですか？，と聞かれています． $n=pq$の定義より，$n$は計算可能です． このような，単純な計算はpythonのインタラクティブ機能が便利です．\n\u0026gt;\u0026gt;\u0026gt; p = 60413 \u0026gt;\u0026gt;\u0026gt; q = 76753 \u0026gt;\u0026gt;\u0026gt; n = p*q \u0026gt;\u0026gt;\u0026gt; n 4636878989 2問目 #### NEW PROBLEM #### p : 54269 n : 5051846941 ##### PRODUCE THE FOLLOWING #### q IS THIS POSSIBLE and FEASIBLE? (Y/N):y $n,p$の値から$q$を求める問題です．$n=pq$から$p=n/q$で求められそうです． 一応，$n$が$p$で割り切れない場合を考慮しておきます．\n\u0026gt;\u0026gt;\u0026gt; p = 54269 \u0026gt;\u0026gt;\u0026gt; n = 5051846941 \u0026gt;\u0026gt;\u0026gt; q = n//p \u0026gt;\u0026gt;\u0026gt; q 93089 \u0026gt;\u0026gt;\u0026gt; p*q == n True 3問目 #### NEW PROBLEM #### e : 3 n : 12738162802910546503821920886905393316386362759567480839428456525224226445173031635306683726182522494910808518920409019414034814409330094245825749680913204566832337704700165993198897029795786969124232138869784626202501366135975223827287812326250577148625360887698930625504334325804587329905617936581116392784684334664204309771430814449606147221349888320403451637882447709796221706470239625292297988766493746209684880843111138170600039888112404411310974758532603998608057008811836384597579147244737606088756299939654265086899096359070667266167754944587948695842171915048619846282873769413489072243477764350071787327913 ##### PRODUCE THE FOLLOWING #### q p IS THIS POSSIBLE and FEASIBLE? (Y/N):n $pq=n$を満たす$p$と$q$を求める問題です． RSA暗号は，$n$から$p,q$を計算することは困難である(ことを利用して安全性としている)ので，これはできません．実際，頑張れば素因数分解できるかもしれませんが，FEASIBLEという単語が，「単純に可能だ」みたいなニュアンスなので，無理やり素因数分解するのはnot FEASIBLEということなのだと思います．\n4問目 #### NEW PROBLEM #### q : 66347 p : 12611 ##### PRODUCE THE FOLLOWING #### totient(n) IS THIS POSSIBLE and FEASIBLE? (Y/N):y totient(n)とは，$\\phi(n)$のことですので，$p,q$から計算できます．\n\u0026gt;\u0026gt;\u0026gt; q = 66347 \u0026gt;\u0026gt;\u0026gt; P = 12611 \u0026gt;\u0026gt;\u0026gt; (p-1)*(q-1) 836623060 5問目 #### NEW PROBLEM #### plaintext : 6357294171489311547190987615544575133581967886499484091352661406414044440475205342882841236357665973431462491355089413710392273380203038793241564304774271529108729717 e : 3 n : 29129463609326322559521123136222078780585451208149138547799121083622333250646678767769126248182207478527881025116332742616201890576280859777513414460842754045651093593251726785499360828237897586278068419875517543013545369871704159718105354690802726645710699029936754265654381929650494383622583174075805797766685192325859982797796060391271817578087472948205626257717479858369754502615173773514087437504532994142632207906501079835037052797306690891600559321673928943158514646572885986881016569647357891598545880304236145548059520898133142087545369179876065657214225826997676844000054327141666320553082128424707948750331 ##### PRODUCE THE FOLLOWING #### ciphertext IS THIS POSSIBLE and FEASIBLE? (Y/N):y $m,e,n$から$c$を求めます．必要なパラメータは揃っているため，計算可能です．\n\u0026gt;\u0026gt;\u0026gt; m = 6357294171489311547190987615544575133581967886499484091352661406414044440475205342882841236357665973431462491355089413710392273380203038793241564304774271529108729717 \u0026gt;\u0026gt;\u0026gt; e = 3 \u0026gt;\u0026gt;\u0026gt; n = 29129463609326322559521123136222078780585451208149138547799121083622333250646678767769126248182207478527881025116332742616201890576280859777513414460842754045651093593251726785499360828237897586278068419875517543013545369871704159718105354690802726645710699029936754265654381929650494383622583174075805797766685192325859982797796060391271817578087472948205626257717479858369754502615173773514087437504532994142632207906501079835037052797306690891600559321673928943158514646572885986881016569647357891598545880304236145548059520898133142087545369179876065657214225826997676844000054327141666320553082128424707948750331 \u0026gt;\u0026gt;\u0026gt; pow(m,e,n) 256931246631782714357241556582441991993437399854161372646318659020994329843524306570818293602492485385337029697819837182169818816821461486018802894936801257629375428544752970630870631166355711254848465862207765051226282541748174535990314552471546936536330397892907207943448897073772015986097770443616540466471245438117157152783246654401668267323136450122287983612851171545784168132230208726238881861407976917850248110805724300421712827401063963117423718797887144760360749619552577176382615108244813 6問目  #### NEW PROBLEM #### ciphertext : 107524013451079348539944510756143604203925717262185033799328445011792760545528944993719783392542163428637172323512252624567111110666168664743115203791510985709942366609626436995887781674651272233566303814979677507101168587739375699009734588985482369702634499544891509228440194615376339573685285125730286623323 e : 3 n : 27566996291508213932419371385141522859343226560050921196294761870500846140132385080994630946107675330189606021165260590147068785820203600882092467797813519434652632126061353583124063944373336654246386074125394368479677295167494332556053947231141336142392086767742035970752738056297057898704112912616565299451359791548536846025854378347423520104947907334451056339439706623069503088916316369813499705073573777577169392401411708920615574908593784282546154486446779246790294398198854547069593987224578333683144886242572837465834139561122101527973799583927411936200068176539747586449939559180772690007261562703222558103359 ##### PRODUCE THE FOLLOWING #### plaintext IS THIS POSSIBLE and FEASIBLE? (Y/N):n $n,e,c$の値から$m$を見つける問題です． これは，公開鍵のみから平文を解読することになってしまうので，RSA暗号の性質としてはそのようなことはできません． 非常にlow exponent attackができそうな見た目をしていますが，そのまま3乗根をとることはできません．ひっかけ問題．\n7問目 #### NEW PROBLEM #### q : 92092076805892533739724722602668675840671093008520241548191914215399824020372076186460768206814914423802230398410980218741906960527104568970225804374404612617736579286959865287226538692911376507934256844456333236362669879347073756238894784951597211105734179388300051579994253565459304743059533646753003894559 p : 97846775312392801037224396977012615848433199640105786119757047098757998273009741128821931277074555731813289423891389911801250326299324018557072727051765547115514791337578758859803890173153277252326496062476389498019821358465433398338364421624871010292162533041884897182597065662521825095949253625730631876637 e : 65537 ##### PRODUCE THE FOLLOWING #### d IS THIS POSSIBLE and FEASIBLE? (Y/N):y $p,q$から$\\phi(n)$が計算できます．\n\u0026gt;\u0026gt;\u0026gt; p = 92092076805892533739724722602668675840671093008520241548191914215399824020372076186460768206814914423802230398410980218741906960527104568970225804374404612617736579286959865287226538692911376507934256844456333236362669879347073756238894784951597211105734179388300051579994253565459304743059533646753003894559 \u0026gt;\u0026gt;\u0026gt; q = 97846775312392801037224396977012615848433199640105786119757047098757998273009741128821931277074555731813289423891389911801250326299324018557072727051765547115514791337578758859803890173153277252326496062476389498019821358465433398338364421624871010292162533041884897182597065662521825095949253625730631876637 \u0026gt;\u0026gt;\u0026gt; phi = (p-1)*(q-1) \u0026gt;\u0026gt;\u0026gt; e = 65537 \u0026gt;\u0026gt;\u0026gt; pow(e,-1,phi) 1405046269503207469140791548403639533127416416214210694972085079171787580463776820425965898174272870486015739516125786182821637006600742140682552321645503743280670839819078749092730110549881891271317396450158021688253989767145578723458252769465545504142139663476747479225923933192421405464414574786272963741656223941750084051228611576708609346787101088759062724389874160693008783334605903142528824559223515203978707969795087506678894006628296743079886244349469131831225757926844843554897638786146036869572653204735650843186722732736888918789379054050122205253165705085538743651258400390580971043144644984654914856729 8問目 #### NEW PROBLEM #### p : 153143042272527868798412612417204434156935146874282990942386694020462861918068684561281763577034706600608387699148071015194725533394126069826857182428660427818277378724977554365910231524827258160904493774748749088477328204812171935987088715261127321911849092207070653272176072509933245978935455542420691737433 ciphertext : 13433290949680532374013867441263154634705815037382789341947905025573905974395028146503162155477260989520870175638250366834087929309236841056522311567941474209163559687755762232926539910909326834168973560610986090744435081572047926364479629414399701920441091626046861493465214197526650146669009590360242375313096062285541413327190041808752295242278877995930751460977420696964385608409717277431821765402461515639686537904799084682553530460611519251872463837425068958992042166507373556839377045616866221238932332390930404993242351071392965945718308504231468783743378794612151028803489143522912976113314577732444166162766 e : 65537 n : 23952937352643527451379227516428377705004894508566304313177880191662177061878993798938496818120987817049538365206671401938265663712351239785237507341311858383628932183083145614696585411921662992078376103990806989257289472590902167457302888198293135333083734504191910953238278860923153746261500759411620299864395158783509535039259714359526738924736952759753503357614939203434092075676169179112452620687731670534906069845965633455748606649062394293289967059348143206600765820021392608270528856238306849191113241355842396325210132358046616312901337987464473799040762271876389031455051640937681745409057246190498795697239 ##### PRODUCE THE FOLLOWING #### plaintext IS THIS POSSIBLE and FEASIBLE? (Y/N):y 方針としては，\n まず，$n,p$から$q$を計算 $p,q$から$\\phi(n)$を計算 $e,phi(n)$から$e$を計算 $c,e,n$から$m$を計算  をすることで平文$m$が求まります．\n\u0026gt;\u0026gt;\u0026gt; p = 153143042272527868798412612417204434156935146874282990942386694020462861918068684561281763577034706600608387699148071015194725533394126069826857182428660427818277378724977554365910231524827258160904493774748749088477328204812171935987088715261127321911849092207070653272176072509933245978935455542420691737433 \u0026gt;\u0026gt;\u0026gt; n = 23952937352643527451379227516428377705004894508566304313177880191662177061878993798938496818120987817049538365206671401938265663712351239785237507341311858383628932183083145614696585411921662992078376103990806989257289472590902167457302888198293135333083734504191910953238278860923153746261500759411620299864395158783509535039259714359526738924736952759753503357614939203434092075676169179112452620687731670534906069845965633455748606649062394293289967059348143206600765820021392608270528856238306849191113241355842396325210132358046616312901337987464473799040762271876389031455051640937681745409057246190498795697239 \u0026gt;\u0026gt;\u0026gt; e = 65537 \u0026gt;\u0026gt;\u0026gt; c = 13433290949680532374013867441263154634705815037382789341947905025573905974395028146503162155477260989520870175638250366834087929309236841056522311567941474209163559687755762232926539910909326834168973560610986090744435081572047926364479629414399701920441091626046861493465214197526650146669009590360242375313096062285541413327190041808752295242278877995930751460977420696964385608409717277431821765402461515639686537904799084682553530460611519251872463837425068958992042166507373556839377045616866221238932332390930404993242351071392965945718308504231468783743378794612151028803489143522912976113314577732444166162766 \u0026gt;\u0026gt;\u0026gt; q = n//p \u0026gt;\u0026gt;\u0026gt; q 156408916769576372285319235535320446340733908943564048157238512311891352879208957302116527435165097143521156600690562005797819820759620198602417583539668686152735534648541252847927334505648478214810780526425005943955838623325525300844493280040860604499838598837599791480284496210333200247148213274376422459183 \u0026gt;\u0026gt;\u0026gt; p*q == n True \u0026gt;\u0026gt;\u0026gt; phi = (p-1)*(q-1) \u0026gt;\u0026gt;\u0026gt; pow(e,-1,phi) 22034129334251191532436631052427142022088744911087428294376533303549714947731798818325604737385904031714383011477708757017443918217594934051491731465975983129741023155187658874730504062262863677059204116473042418196655483682312571059072267891580301964167098006533984400230039789561227549336513668349914598133972091774519248676772440875769025772999278219313806132022105603602125065517276257780089695487263525233311631530270816107086663522684249560931634897706468898520986823978521565593553989544219514141658868117625286137870896148765109851519254459305427251830096270116145359667655034114642356864731801259263519426097 \u0026gt;\u0026gt;\u0026gt; d = pow(e,-1,phi) \u0026gt;\u0026gt;\u0026gt; pow(c,d,n) 14311663942709674867122208214901970650496788151239520971623411712977120527163003942343369341 If you convert the last plaintext to a hex number, then ascii, you\u0026#39;ll find what you need! ;) この答えがそのままflagになっているので，デコードします．\n\u0026gt;\u0026gt;\u0026gt; from Crypto.Util.number import long_to_bytes \u0026gt;\u0026gt;\u0026gt; long_to_bytes(14311663942709674867122208214901970650496788151239520971623411712977120527163003942343369341) b\u0026#39;picoCTF{wA8_th4t$_ill3aGal..oa2d2239b}\u0026#39; 余談 Noと答える問題は混乱するので，ない方が良かったと思います\u0026hellip;\u0026hellip; あと，ncを繋いだまま計算することになるので，地味にタイムアウトが厳しいです． 何回か周回することになりました．\n","permalink":"https://shibaken28.github.io/my-blog/post/ctf/crypto/pico/rsa-pop-quiz/","summary":"picoCTFの過去問が，常設ctfとして楽しめるpicoGymの問題です．\n概要 Class, take your seats! It\u0026#39;s PRIME-time for a quiz... nc jupiter.challenges.picoctf.org 18821 ncすると，RSA暗号の基本知識を問われます．\n解答 基本 この問題を解くにあたって，次の各パラメータの関係を知っておく必要があります．\n$p,q$を素数，$n=pq$とする．また，$e$を適当な正の整数とする． 平文(plaintext)を$m$とすると，暗号文(ciphertext)$c$は $$c = m^e \\mod n$$ で計算され，秘密鍵$d$を $$d = e^{-1} \\mod \\phi(n)$$ と計算すると，平文$m$が $$m = c^d \\mod n$$ で求めることができる． なお，この場合，$\\phi(n) = (p-1)(q-1)$である．\npythonでは，$a^b \\mod c$をpow(a,b,c)で計算することができる($b=-1$でも動作する)．\n解法 1問目 ncすると次のメッセージが表示されます．\nGood morning class! It\u0026#39;s me Ms. Adleman-Shamir-Rivest Today we will be taking a pop quiz, so I hope you studied. Cramming just will not do!","title":"picoGym - rsa-pop-quiz"},{"content":"問題 ctfTimeの問題ページ out.txtは次のようになっています．\np = 127557933868274766492781168166651795645253551106939814103375361345423596703884421796150924794852741931334746816404778765897684777811408386179315837751682393250322682273488477810275794941270780027115435485813413822503016999058941190903932883823 e1 = 219560036291700924162367491740680392841 e2 = 325829142086458078752836113369745585569 e3 = 237262361171684477270779152881433264701 c = 962976093858853504877937799237367527464560456536071770645193845048591657714868645727169308285896910567283470660044952959089092802768837038911347652160892917850466319249036343642773207046774240176141525105555149800395040339351956120433647613 平文を$m$，ある素数を$p$とすると，$m^e \\bmod p = c$として暗号文$c$を求めています．ただし，$e = {e_1}^{{e_2}^{e_3}}$です． $e_1,e_2,e_3$が与えられているので，$e$を求めれば $d = e^{-1} \\pmod{\\phi(p)} $として$c^d \\pmod p$で平文が求まります．\nしかし，$e$を実際に計算しようとすると無限時間かかります． どう計算するかが問題です．\n解答 $e$の値は$\\bmod {\\phi(p)}$の世界で考えても問題ありません． ${e_1}^{{e_2}^{e_3}} \\pmod{\\phi(p)}$の値を求めていきます． オイラーの定理より，次が成り立ちます． $${e_1}^{\\phi(\\phi(p))} = 1 \\pmod{\\phi(p)} $$ $p$は素数であるので，$\\phi(p)=p-1$です(フェルマーの小定理)．よって，次のように書き換えられます． $${e_1}^{\\phi(p-1)} = 1 \\pmod{p-1}$$\n整数$k$と$l$を使って，${e_2}^{e_3} = \\phi(p-1)k+l$と表されたとします．これは，${e_2}^{e_3}$を$\\phi(p-1)$で割ったときに商が$k$，余りが$l$になったことを表しています． すると， $${e_1}^{{e_2}^{e_3}} = {e_1}^{ \\phi(p-1)k+l} = ({e_1}^{\\phi(p-1)})^k\\cdot {e_1}^l = 1^k \\cdot {e_1}^l = {e_1}^l \\pmod{p-1}$$\nと計算できます．つまり，$l={e_2}^{e_3} \\pmod{\\phi(p-1)}$として，${e_1}^l \\pmod{p-1}$を計算すれば$e$が求まります．\n$\\phi(p-1)$を計算するには，$p-1$を素因数分解しなければなりませんが，$p-1$は小さい素因数で構成(smooth呼ばれる性質です)されているため，愚直なプログラムで素因数が求まります．1\n以下，pythonでのプログラムを示します． なお，sagemathにはeuler_phi関数が用意されています．\nfrom Crypto.Util.number import long_to_bytes  def euler_phi(N):  factor = []  i = 2  # 素因数分解  while True:  if i*i\u0026gt;N:  factor.append(N)  break  if N%i==0:  factor.append(i)  N = N // i  else:  i+=1   # 素因数-1を掛け算していく  phi = 1  for p in factor:  phi *= p-1   return phi  p = 127557933868274766492781168166651795645253551106939814103375361345423596703884421796150924794852741931334746816404778765897684777811408386179315837751682393250322682273488477810275794941270780027115435485813413822503016999058941190903932883823 e1 = 219560036291700924162367491740680392841 e2 = 325829142086458078752836113369745585569 e3 = 237262361171684477270779152881433264701 c = 962976093858853504877937799237367527464560456536071770645193845048591657714868645727169308285896910567283470660044952959089092802768837038911347652160892917850466319249036343642773207046774240176141525105555149800395040339351956120433647613  phi_p = p - 1 phi_phi_p = euler_phi(phi_p)  e = pow(e1,pow(e2,e3,phi_phi_p), phi_p) d = pow(e,-1,phi_p) m = pow(c,d,p)  print(\u0026#34;phi(p) : \u0026#34;,phi_p) print(\u0026#34;phi(phi(p)): \u0026#34;,phi_phi_p) print(long_to_bytes(m)) 結果\nphi(p) : 127557933868274766492781168166651795645253551106939814103375361345423596703884421796150924794852741931334746816404778765897684777811408386179315837751682393250322682273488477810275794941270780027115435485813413822503016999058941190903932883822 phi(phi(p)): 63775594668498404422995279661693309334486076035802944116275814269950078792958445557761589097717204934857369990271713664698474867142217580223510594284968730411939236198524531363514002763605853593498040656788050786948899096447734618521600000000 b\u0026#39;crew{7hi5_1s_4_5ma11er_numb3r_7han_7h3_Gr4ham_numb3r}\u0026#39;   追記(2022/5/9)：ここに示したphiを計算するプログラムは不十分でした．低確率ながら，同じ素数が2つ以上含まれる可能性があるからです．その場合は$p^e$とすると$p^e-p^{e-1}$の掛け算が必要になります\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://shibaken28.github.io/my-blog/post/ctf/crypto/crew/thehugee/","summary":"問題 ctfTimeの問題ページ out.txtは次のようになっています．\np = 127557933868274766492781168166651795645253551106939814103375361345423596703884421796150924794852741931334746816404778765897684777811408386179315837751682393250322682273488477810275794941270780027115435485813413822503016999058941190903932883823 e1 = 219560036291700924162367491740680392841 e2 = 325829142086458078752836113369745585569 e3 = 237262361171684477270779152881433264701 c = 962976093858853504877937799237367527464560456536071770645193845048591657714868645727169308285896910567283470660044952959089092802768837038911347652160892917850466319249036343642773207046774240176141525105555149800395040339351956120433647613 平文を$m$，ある素数を$p$とすると，$m^e \\bmod p = c$として暗号文$c$を求めています．ただし，$e = {e_1}^{{e_2}^{e_3}}$です． $e_1,e_2,e_3$が与えられているので，$e$を求めれば $d = e^{-1} \\pmod{\\phi(p)} $として$c^d \\pmod p$で平文が求まります．\nしかし，$e$を実際に計算しようとすると無限時間かかります． どう計算するかが問題です．\n解答 $e$の値は$\\bmod {\\phi(p)}$の世界で考えても問題ありません． ${e_1}^{{e_2}^{e_3}} \\pmod{\\phi(p)}$の値を求めていきます． オイラーの定理より，次が成り立ちます． $${e_1}^{\\phi(\\phi(p))} = 1 \\pmod{\\phi(p)} $$ $p$は素数であるので，$\\phi(p)=p-1$です(フェルマーの小定理)．よって，次のように書き換えられます． $${e_1}^{\\phi(p-1)} = 1 \\pmod{p-1}$$\n整数$k$と$l$を使って，${e_2}^{e_3} = \\phi(p-1)k+l$と表されたとします．これは，${e_2}^{e_3}$を$\\phi(p-1)$で割ったときに商が$k$，余りが$l$になったことを表しています． すると， $${e_1}^{{e_2}^{e_3}} = {e_1}^{ \\phi(p-1)k+l} = ({e_1}^{\\phi(p-1)})^k\\cdot {e_1}^l = 1^k \\cdot {e_1}^l = {e_1}^l \\pmod{p-1}$$\nと計算できます．つまり，$l={e_2}^{e_3} \\pmod{\\phi(p-1)}$として，${e_1}^l \\pmod{p-1}$を計算すれば$e$が求まります．","title":"CrewCTF 2022 - The Huge E"},{"content":"目的 しょっちゅう忘れてはググってるのでまとめます．\nCrypto.Util.number long_to_bytes,bytes_to_long bytes型とlong型を変換する．\n\u0026gt;\u0026gt;\u0026gt; bytes_to_long(b\u0026#39;hello\u0026#39;) 448378203247 \u0026gt;\u0026gt;\u0026gt; long_to_bytes(0x68656c6c6f) b\u0026#39;hello\u0026#39; inverse inverse(a,b)でaをmodbでの逆元を得られる．\n\u0026gt;\u0026gt;\u0026gt; inverse(3,7) 5 \u0026gt;\u0026gt;\u0026gt; 3*inverse(3,7)%7 1 なお，デフォルトで使えるpow関数で代用可能．\n\u0026gt;\u0026gt;\u0026gt; pow(3,-1,7) 5 getPrime getPrime(a)でaビットの素数が生成される\n\u0026gt;\u0026gt;\u0026gt; getPrime(10) 911 \u0026gt;\u0026gt;\u0026gt; bin(911) \u0026#39;0b1110001111\u0026#39; \u0026gt;\u0026gt;\u0026gt; Crypto.PublicKey pemファイルを開くことができる． 使用例\nfrom Crypto.PublicKey import RSA openssl rsa -text -in idk.keyf=open(\u0026#39;key.pem\u0026#39;,\u0026#39;rb\u0026#39;) pubkey = RSA.importKey(f.read()) print(pubkey) print(\u0026#34;n:\u0026#34;,pubkey.n) print(\u0026#34;e:\u0026#34;,pubkey.e) gmpy2 iroot iroot(a,b)でaのb乗根が得られる．タプル型で返る．\nsagemath  ","permalink":"https://shibaken28.github.io/my-blog/post/ctf/crypto/general/","summary":"目的 しょっちゅう忘れてはググってるのでまとめます．\nCrypto.Util.number long_to_bytes,bytes_to_long bytes型とlong型を変換する．\n\u0026gt;\u0026gt;\u0026gt; bytes_to_long(b\u0026#39;hello\u0026#39;) 448378203247 \u0026gt;\u0026gt;\u0026gt; long_to_bytes(0x68656c6c6f) b\u0026#39;hello\u0026#39; inverse inverse(a,b)でaをmodbでの逆元を得られる．\n\u0026gt;\u0026gt;\u0026gt; inverse(3,7) 5 \u0026gt;\u0026gt;\u0026gt; 3*inverse(3,7)%7 1 なお，デフォルトで使えるpow関数で代用可能．\n\u0026gt;\u0026gt;\u0026gt; pow(3,-1,7) 5 getPrime getPrime(a)でaビットの素数が生成される\n\u0026gt;\u0026gt;\u0026gt; getPrime(10) 911 \u0026gt;\u0026gt;\u0026gt; bin(911) \u0026#39;0b1110001111\u0026#39; \u0026gt;\u0026gt;\u0026gt; Crypto.PublicKey pemファイルを開くことができる． 使用例\nfrom Crypto.PublicKey import RSA openssl rsa -text -in idk.keyf=open(\u0026#39;key.pem\u0026#39;,\u0026#39;rb\u0026#39;) pubkey = RSA.importKey(f.read()) print(pubkey) print(\u0026#34;n:\u0026#34;,pubkey.n) print(\u0026#34;e:\u0026#34;,pubkey.e) gmpy2 iroot iroot(a,b)でaのb乗根が得られる．タプル型で返る．\nsagemath  ","title":"crypto問でよく使うライブラリ，関数など"}]